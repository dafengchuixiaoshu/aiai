// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ContactsParamsPOJO.proto

#ifndef PROTOBUF_ContactsParamsPOJO_2eproto__INCLUDED
#define PROTOBUF_ContactsParamsPOJO_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace mm {
namespace pb {
namespace po {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ContactsParamsPOJO_2eproto();
void protobuf_AssignDesc_ContactsParamsPOJO_2eproto();
void protobuf_ShutdownFile_ContactsParamsPOJO_2eproto();

class ContactsParamsPOJO;
class Contacts;
class ConName;
class ConPhone;
class ResultContacts;
class MyVCard;

// ===================================================================

class ContactsParamsPOJO : public ::google::protobuf::Message {
 public:
  ContactsParamsPOJO();
  virtual ~ContactsParamsPOJO();

  ContactsParamsPOJO(const ContactsParamsPOJO& from);

  inline ContactsParamsPOJO& operator=(const ContactsParamsPOJO& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContactsParamsPOJO& default_instance();

  void Swap(ContactsParamsPOJO* other);

  // implements Message ----------------------------------------------

  ContactsParamsPOJO* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ContactsParamsPOJO& from);
  void MergeFrom(const ContactsParamsPOJO& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // optional .com.mm.pb.po.MyVCard myVCard = 2;
  inline bool has_myvcard() const;
  inline void clear_myvcard();
  static const int kMyVCardFieldNumber = 2;
  inline const ::com::mm::pb::po::MyVCard& myvcard() const;
  inline ::com::mm::pb::po::MyVCard* mutable_myvcard();
  inline ::com::mm::pb::po::MyVCard* release_myvcard();
  inline void set_allocated_myvcard(::com::mm::pb::po::MyVCard* myvcard);

  // repeated .com.mm.pb.po.Contacts contactsList = 3;
  inline int contactslist_size() const;
  inline void clear_contactslist();
  static const int kContactsListFieldNumber = 3;
  inline const ::com::mm::pb::po::Contacts& contactslist(int index) const;
  inline ::com::mm::pb::po::Contacts* mutable_contactslist(int index);
  inline ::com::mm::pb::po::Contacts* add_contactslist();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mm::pb::po::Contacts >&
      contactslist() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mm::pb::po::Contacts >*
      mutable_contactslist();

  // repeated .com.mm.pb.po.ResultContacts resultContacts = 4;
  inline int resultcontacts_size() const;
  inline void clear_resultcontacts();
  static const int kResultContactsFieldNumber = 4;
  inline const ::com::mm::pb::po::ResultContacts& resultcontacts(int index) const;
  inline ::com::mm::pb::po::ResultContacts* mutable_resultcontacts(int index);
  inline ::com::mm::pb::po::ResultContacts* add_resultcontacts();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mm::pb::po::ResultContacts >&
      resultcontacts() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mm::pb::po::ResultContacts >*
      mutable_resultcontacts();

  // optional int32 resultCode = 5;
  inline bool has_resultcode() const;
  inline void clear_resultcode();
  static const int kResultCodeFieldNumber = 5;
  inline ::google::protobuf::int32 resultcode() const;
  inline void set_resultcode(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:com.mm.pb.po.ContactsParamsPOJO)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_myvcard();
  inline void clear_has_myvcard();
  inline void set_has_resultcode();
  inline void clear_has_resultcode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::com::mm::pb::po::MyVCard* myvcard_;
  ::google::protobuf::RepeatedPtrField< ::com::mm::pb::po::Contacts > contactslist_;
  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 resultcode_;
  ::google::protobuf::RepeatedPtrField< ::com::mm::pb::po::ResultContacts > resultcontacts_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ContactsParamsPOJO_2eproto();
  friend void protobuf_AssignDesc_ContactsParamsPOJO_2eproto();
  friend void protobuf_ShutdownFile_ContactsParamsPOJO_2eproto();

  void InitAsDefaultInstance();
  static ContactsParamsPOJO* default_instance_;
};
// -------------------------------------------------------------------

class Contacts : public ::google::protobuf::Message {
 public:
  Contacts();
  virtual ~Contacts();

  Contacts(const Contacts& from);

  inline Contacts& operator=(const Contacts& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Contacts& default_instance();

  void Swap(Contacts* other);

  // implements Message ----------------------------------------------

  Contacts* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Contacts& from);
  void MergeFrom(const Contacts& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .com.mm.pb.po.ConName name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::com::mm::pb::po::ConName& name() const;
  inline ::com::mm::pb::po::ConName* mutable_name();
  inline ::com::mm::pb::po::ConName* release_name();
  inline void set_allocated_name(::com::mm::pb::po::ConName* name);

  // repeated .com.mm.pb.po.ConPhone phone = 2;
  inline int phone_size() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 2;
  inline const ::com::mm::pb::po::ConPhone& phone(int index) const;
  inline ::com::mm::pb::po::ConPhone* mutable_phone(int index);
  inline ::com::mm::pb::po::ConPhone* add_phone();
  inline const ::google::protobuf::RepeatedPtrField< ::com::mm::pb::po::ConPhone >&
      phone() const;
  inline ::google::protobuf::RepeatedPtrField< ::com::mm::pb::po::ConPhone >*
      mutable_phone();

  // @@protoc_insertion_point(class_scope:com.mm.pb.po.Contacts)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::com::mm::pb::po::ConName* name_;
  ::google::protobuf::RepeatedPtrField< ::com::mm::pb::po::ConPhone > phone_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ContactsParamsPOJO_2eproto();
  friend void protobuf_AssignDesc_ContactsParamsPOJO_2eproto();
  friend void protobuf_ShutdownFile_ContactsParamsPOJO_2eproto();

  void InitAsDefaultInstance();
  static Contacts* default_instance_;
};
// -------------------------------------------------------------------

class ConName : public ::google::protobuf::Message {
 public:
  ConName();
  virtual ~ConName();

  ConName(const ConName& from);

  inline ConName& operator=(const ConName& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConName& default_instance();

  void Swap(ConName* other);

  // implements Message ----------------------------------------------

  ConName* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConName& from);
  void MergeFrom(const ConName& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string firstName = 1;
  inline bool has_firstname() const;
  inline void clear_firstname();
  static const int kFirstNameFieldNumber = 1;
  inline const ::std::string& firstname() const;
  inline void set_firstname(const ::std::string& value);
  inline void set_firstname(const char* value);
  inline void set_firstname(const char* value, size_t size);
  inline ::std::string* mutable_firstname();
  inline ::std::string* release_firstname();
  inline void set_allocated_firstname(::std::string* firstname);

  // optional string lastName = 2;
  inline bool has_lastname() const;
  inline void clear_lastname();
  static const int kLastNameFieldNumber = 2;
  inline const ::std::string& lastname() const;
  inline void set_lastname(const ::std::string& value);
  inline void set_lastname(const char* value);
  inline void set_lastname(const char* value, size_t size);
  inline ::std::string* mutable_lastname();
  inline ::std::string* release_lastname();
  inline void set_allocated_lastname(::std::string* lastname);

  // @@protoc_insertion_point(class_scope:com.mm.pb.po.ConName)
 private:
  inline void set_has_firstname();
  inline void clear_has_firstname();
  inline void set_has_lastname();
  inline void clear_has_lastname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* firstname_;
  ::std::string* lastname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ContactsParamsPOJO_2eproto();
  friend void protobuf_AssignDesc_ContactsParamsPOJO_2eproto();
  friend void protobuf_ShutdownFile_ContactsParamsPOJO_2eproto();

  void InitAsDefaultInstance();
  static ConName* default_instance_;
};
// -------------------------------------------------------------------

class ConPhone : public ::google::protobuf::Message {
 public:
  ConPhone();
  virtual ~ConPhone();

  ConPhone(const ConPhone& from);

  inline ConPhone& operator=(const ConPhone& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConPhone& default_instance();

  void Swap(ConPhone* other);

  // implements Message ----------------------------------------------

  ConPhone* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConPhone& from);
  void MergeFrom(const ConPhone& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:com.mm.pb.po.ConPhone)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* type_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ContactsParamsPOJO_2eproto();
  friend void protobuf_AssignDesc_ContactsParamsPOJO_2eproto();
  friend void protobuf_ShutdownFile_ContactsParamsPOJO_2eproto();

  void InitAsDefaultInstance();
  static ConPhone* default_instance_;
};
// -------------------------------------------------------------------

class ResultContacts : public ::google::protobuf::Message {
 public:
  ResultContacts();
  virtual ~ResultContacts();

  ResultContacts(const ResultContacts& from);

  inline ResultContacts& operator=(const ResultContacts& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResultContacts& default_instance();

  void Swap(ResultContacts* other);

  // implements Message ----------------------------------------------

  ResultContacts* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResultContacts& from);
  void MergeFrom(const ResultContacts& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string nickname = 1;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 1;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional string phone = 2;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 2;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional string face_url = 3;
  inline bool has_face_url() const;
  inline void clear_face_url();
  static const int kFaceUrlFieldNumber = 3;
  inline const ::std::string& face_url() const;
  inline void set_face_url(const ::std::string& value);
  inline void set_face_url(const char* value);
  inline void set_face_url(const char* value, size_t size);
  inline ::std::string* mutable_face_url();
  inline ::std::string* release_face_url();
  inline void set_allocated_face_url(::std::string* face_url);

  // optional int32 otherId = 4;
  inline bool has_otherid() const;
  inline void clear_otherid();
  static const int kOtherIdFieldNumber = 4;
  inline ::google::protobuf::int32 otherid() const;
  inline void set_otherid(::google::protobuf::int32 value);

  // optional string userName = 5;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUserNameFieldNumber = 5;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional int32 status = 6;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 6;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional .com.mm.pb.po.ConName name = 7;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 7;
  inline const ::com::mm::pb::po::ConName& name() const;
  inline ::com::mm::pb::po::ConName* mutable_name();
  inline ::com::mm::pb::po::ConName* release_name();
  inline void set_allocated_name(::com::mm::pb::po::ConName* name);

  // @@protoc_insertion_point(class_scope:com.mm.pb.po.ResultContacts)
 private:
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_face_url();
  inline void clear_has_face_url();
  inline void set_has_otherid();
  inline void clear_has_otherid();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* nickname_;
  ::std::string* phone_;
  ::std::string* face_url_;
  ::std::string* username_;
  ::google::protobuf::int32 otherid_;
  ::google::protobuf::int32 status_;
  ::com::mm::pb::po::ConName* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_ContactsParamsPOJO_2eproto();
  friend void protobuf_AssignDesc_ContactsParamsPOJO_2eproto();
  friend void protobuf_ShutdownFile_ContactsParamsPOJO_2eproto();

  void InitAsDefaultInstance();
  static ResultContacts* default_instance_;
};
// -------------------------------------------------------------------

class MyVCard : public ::google::protobuf::Message {
 public:
  MyVCard();
  virtual ~MyVCard();

  MyVCard(const MyVCard& from);

  inline MyVCard& operator=(const MyVCard& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MyVCard& default_instance();

  void Swap(MyVCard* other);

  // implements Message ----------------------------------------------

  MyVCard* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MyVCard& from);
  void MergeFrom(const MyVCard& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string phone = 2;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 2;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional string email = 3;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 3;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // @@protoc_insertion_point(class_scope:com.mm.pb.po.MyVCard)
 private:
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_email();
  inline void clear_has_email();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* phone_;
  ::std::string* email_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ContactsParamsPOJO_2eproto();
  friend void protobuf_AssignDesc_ContactsParamsPOJO_2eproto();
  friend void protobuf_ShutdownFile_ContactsParamsPOJO_2eproto();

  void InitAsDefaultInstance();
  static MyVCard* default_instance_;
};
// ===================================================================


// ===================================================================

// ContactsParamsPOJO

// optional int32 uid = 1;
inline bool ContactsParamsPOJO::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContactsParamsPOJO::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContactsParamsPOJO::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContactsParamsPOJO::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 ContactsParamsPOJO::uid() const {
  return uid_;
}
inline void ContactsParamsPOJO::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// optional .com.mm.pb.po.MyVCard myVCard = 2;
inline bool ContactsParamsPOJO::has_myvcard() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContactsParamsPOJO::set_has_myvcard() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContactsParamsPOJO::clear_has_myvcard() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContactsParamsPOJO::clear_myvcard() {
  if (myvcard_ != NULL) myvcard_->::com::mm::pb::po::MyVCard::Clear();
  clear_has_myvcard();
}
inline const ::com::mm::pb::po::MyVCard& ContactsParamsPOJO::myvcard() const {
  return myvcard_ != NULL ? *myvcard_ : *default_instance_->myvcard_;
}
inline ::com::mm::pb::po::MyVCard* ContactsParamsPOJO::mutable_myvcard() {
  set_has_myvcard();
  if (myvcard_ == NULL) myvcard_ = new ::com::mm::pb::po::MyVCard;
  return myvcard_;
}
inline ::com::mm::pb::po::MyVCard* ContactsParamsPOJO::release_myvcard() {
  clear_has_myvcard();
  ::com::mm::pb::po::MyVCard* temp = myvcard_;
  myvcard_ = NULL;
  return temp;
}
inline void ContactsParamsPOJO::set_allocated_myvcard(::com::mm::pb::po::MyVCard* myvcard) {
  delete myvcard_;
  myvcard_ = myvcard;
  if (myvcard) {
    set_has_myvcard();
  } else {
    clear_has_myvcard();
  }
}

// repeated .com.mm.pb.po.Contacts contactsList = 3;
inline int ContactsParamsPOJO::contactslist_size() const {
  return contactslist_.size();
}
inline void ContactsParamsPOJO::clear_contactslist() {
  contactslist_.Clear();
}
inline const ::com::mm::pb::po::Contacts& ContactsParamsPOJO::contactslist(int index) const {
  return contactslist_.Get(index);
}
inline ::com::mm::pb::po::Contacts* ContactsParamsPOJO::mutable_contactslist(int index) {
  return contactslist_.Mutable(index);
}
inline ::com::mm::pb::po::Contacts* ContactsParamsPOJO::add_contactslist() {
  return contactslist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mm::pb::po::Contacts >&
ContactsParamsPOJO::contactslist() const {
  return contactslist_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mm::pb::po::Contacts >*
ContactsParamsPOJO::mutable_contactslist() {
  return &contactslist_;
}

// repeated .com.mm.pb.po.ResultContacts resultContacts = 4;
inline int ContactsParamsPOJO::resultcontacts_size() const {
  return resultcontacts_.size();
}
inline void ContactsParamsPOJO::clear_resultcontacts() {
  resultcontacts_.Clear();
}
inline const ::com::mm::pb::po::ResultContacts& ContactsParamsPOJO::resultcontacts(int index) const {
  return resultcontacts_.Get(index);
}
inline ::com::mm::pb::po::ResultContacts* ContactsParamsPOJO::mutable_resultcontacts(int index) {
  return resultcontacts_.Mutable(index);
}
inline ::com::mm::pb::po::ResultContacts* ContactsParamsPOJO::add_resultcontacts() {
  return resultcontacts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mm::pb::po::ResultContacts >&
ContactsParamsPOJO::resultcontacts() const {
  return resultcontacts_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mm::pb::po::ResultContacts >*
ContactsParamsPOJO::mutable_resultcontacts() {
  return &resultcontacts_;
}

// optional int32 resultCode = 5;
inline bool ContactsParamsPOJO::has_resultcode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ContactsParamsPOJO::set_has_resultcode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ContactsParamsPOJO::clear_has_resultcode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ContactsParamsPOJO::clear_resultcode() {
  resultcode_ = 0;
  clear_has_resultcode();
}
inline ::google::protobuf::int32 ContactsParamsPOJO::resultcode() const {
  return resultcode_;
}
inline void ContactsParamsPOJO::set_resultcode(::google::protobuf::int32 value) {
  set_has_resultcode();
  resultcode_ = value;
}

// -------------------------------------------------------------------

// Contacts

// optional .com.mm.pb.po.ConName name = 1;
inline bool Contacts::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Contacts::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Contacts::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Contacts::clear_name() {
  if (name_ != NULL) name_->::com::mm::pb::po::ConName::Clear();
  clear_has_name();
}
inline const ::com::mm::pb::po::ConName& Contacts::name() const {
  return name_ != NULL ? *name_ : *default_instance_->name_;
}
inline ::com::mm::pb::po::ConName* Contacts::mutable_name() {
  set_has_name();
  if (name_ == NULL) name_ = new ::com::mm::pb::po::ConName;
  return name_;
}
inline ::com::mm::pb::po::ConName* Contacts::release_name() {
  clear_has_name();
  ::com::mm::pb::po::ConName* temp = name_;
  name_ = NULL;
  return temp;
}
inline void Contacts::set_allocated_name(::com::mm::pb::po::ConName* name) {
  delete name_;
  name_ = name;
  if (name) {
    set_has_name();
  } else {
    clear_has_name();
  }
}

// repeated .com.mm.pb.po.ConPhone phone = 2;
inline int Contacts::phone_size() const {
  return phone_.size();
}
inline void Contacts::clear_phone() {
  phone_.Clear();
}
inline const ::com::mm::pb::po::ConPhone& Contacts::phone(int index) const {
  return phone_.Get(index);
}
inline ::com::mm::pb::po::ConPhone* Contacts::mutable_phone(int index) {
  return phone_.Mutable(index);
}
inline ::com::mm::pb::po::ConPhone* Contacts::add_phone() {
  return phone_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::com::mm::pb::po::ConPhone >&
Contacts::phone() const {
  return phone_;
}
inline ::google::protobuf::RepeatedPtrField< ::com::mm::pb::po::ConPhone >*
Contacts::mutable_phone() {
  return &phone_;
}

// -------------------------------------------------------------------

// ConName

// optional string firstName = 1;
inline bool ConName::has_firstname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConName::set_has_firstname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConName::clear_has_firstname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConName::clear_firstname() {
  if (firstname_ != &::google::protobuf::internal::kEmptyString) {
    firstname_->clear();
  }
  clear_has_firstname();
}
inline const ::std::string& ConName::firstname() const {
  return *firstname_;
}
inline void ConName::set_firstname(const ::std::string& value) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::kEmptyString) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(value);
}
inline void ConName::set_firstname(const char* value) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::kEmptyString) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(value);
}
inline void ConName::set_firstname(const char* value, size_t size) {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::kEmptyString) {
    firstname_ = new ::std::string;
  }
  firstname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConName::mutable_firstname() {
  set_has_firstname();
  if (firstname_ == &::google::protobuf::internal::kEmptyString) {
    firstname_ = new ::std::string;
  }
  return firstname_;
}
inline ::std::string* ConName::release_firstname() {
  clear_has_firstname();
  if (firstname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = firstname_;
    firstname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConName::set_allocated_firstname(::std::string* firstname) {
  if (firstname_ != &::google::protobuf::internal::kEmptyString) {
    delete firstname_;
  }
  if (firstname) {
    set_has_firstname();
    firstname_ = firstname;
  } else {
    clear_has_firstname();
    firstname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string lastName = 2;
inline bool ConName::has_lastname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConName::set_has_lastname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConName::clear_has_lastname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConName::clear_lastname() {
  if (lastname_ != &::google::protobuf::internal::kEmptyString) {
    lastname_->clear();
  }
  clear_has_lastname();
}
inline const ::std::string& ConName::lastname() const {
  return *lastname_;
}
inline void ConName::set_lastname(const ::std::string& value) {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::kEmptyString) {
    lastname_ = new ::std::string;
  }
  lastname_->assign(value);
}
inline void ConName::set_lastname(const char* value) {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::kEmptyString) {
    lastname_ = new ::std::string;
  }
  lastname_->assign(value);
}
inline void ConName::set_lastname(const char* value, size_t size) {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::kEmptyString) {
    lastname_ = new ::std::string;
  }
  lastname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConName::mutable_lastname() {
  set_has_lastname();
  if (lastname_ == &::google::protobuf::internal::kEmptyString) {
    lastname_ = new ::std::string;
  }
  return lastname_;
}
inline ::std::string* ConName::release_lastname() {
  clear_has_lastname();
  if (lastname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = lastname_;
    lastname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConName::set_allocated_lastname(::std::string* lastname) {
  if (lastname_ != &::google::protobuf::internal::kEmptyString) {
    delete lastname_;
  }
  if (lastname) {
    set_has_lastname();
    lastname_ = lastname;
  } else {
    clear_has_lastname();
    lastname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ConPhone

// optional string type = 1;
inline bool ConPhone::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConPhone::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConPhone::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConPhone::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& ConPhone::type() const {
  return *type_;
}
inline void ConPhone::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void ConPhone::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void ConPhone::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConPhone::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* ConPhone::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConPhone::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value = 2;
inline bool ConPhone::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConPhone::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConPhone::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConPhone::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& ConPhone::value() const {
  return *value_;
}
inline void ConPhone::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ConPhone::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ConPhone::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConPhone::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* ConPhone::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConPhone::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResultContacts

// optional string nickname = 1;
inline bool ResultContacts::has_nickname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResultContacts::set_has_nickname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResultContacts::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResultContacts::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& ResultContacts::nickname() const {
  return *nickname_;
}
inline void ResultContacts::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void ResultContacts::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void ResultContacts::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResultContacts::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* ResultContacts::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResultContacts::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string phone = 2;
inline bool ResultContacts::has_phone() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResultContacts::set_has_phone() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResultContacts::clear_has_phone() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResultContacts::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& ResultContacts::phone() const {
  return *phone_;
}
inline void ResultContacts::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void ResultContacts::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void ResultContacts::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResultContacts::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* ResultContacts::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResultContacts::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string face_url = 3;
inline bool ResultContacts::has_face_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResultContacts::set_has_face_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResultContacts::clear_has_face_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResultContacts::clear_face_url() {
  if (face_url_ != &::google::protobuf::internal::kEmptyString) {
    face_url_->clear();
  }
  clear_has_face_url();
}
inline const ::std::string& ResultContacts::face_url() const {
  return *face_url_;
}
inline void ResultContacts::set_face_url(const ::std::string& value) {
  set_has_face_url();
  if (face_url_ == &::google::protobuf::internal::kEmptyString) {
    face_url_ = new ::std::string;
  }
  face_url_->assign(value);
}
inline void ResultContacts::set_face_url(const char* value) {
  set_has_face_url();
  if (face_url_ == &::google::protobuf::internal::kEmptyString) {
    face_url_ = new ::std::string;
  }
  face_url_->assign(value);
}
inline void ResultContacts::set_face_url(const char* value, size_t size) {
  set_has_face_url();
  if (face_url_ == &::google::protobuf::internal::kEmptyString) {
    face_url_ = new ::std::string;
  }
  face_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResultContacts::mutable_face_url() {
  set_has_face_url();
  if (face_url_ == &::google::protobuf::internal::kEmptyString) {
    face_url_ = new ::std::string;
  }
  return face_url_;
}
inline ::std::string* ResultContacts::release_face_url() {
  clear_has_face_url();
  if (face_url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = face_url_;
    face_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResultContacts::set_allocated_face_url(::std::string* face_url) {
  if (face_url_ != &::google::protobuf::internal::kEmptyString) {
    delete face_url_;
  }
  if (face_url) {
    set_has_face_url();
    face_url_ = face_url;
  } else {
    clear_has_face_url();
    face_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 otherId = 4;
inline bool ResultContacts::has_otherid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResultContacts::set_has_otherid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResultContacts::clear_has_otherid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResultContacts::clear_otherid() {
  otherid_ = 0;
  clear_has_otherid();
}
inline ::google::protobuf::int32 ResultContacts::otherid() const {
  return otherid_;
}
inline void ResultContacts::set_otherid(::google::protobuf::int32 value) {
  set_has_otherid();
  otherid_ = value;
}

// optional string userName = 5;
inline bool ResultContacts::has_username() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResultContacts::set_has_username() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResultContacts::clear_has_username() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResultContacts::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& ResultContacts::username() const {
  return *username_;
}
inline void ResultContacts::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ResultContacts::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void ResultContacts::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResultContacts::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* ResultContacts::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResultContacts::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 status = 6;
inline bool ResultContacts::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResultContacts::set_has_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResultContacts::clear_has_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResultContacts::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 ResultContacts::status() const {
  return status_;
}
inline void ResultContacts::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional .com.mm.pb.po.ConName name = 7;
inline bool ResultContacts::has_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResultContacts::set_has_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResultContacts::clear_has_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResultContacts::clear_name() {
  if (name_ != NULL) name_->::com::mm::pb::po::ConName::Clear();
  clear_has_name();
}
inline const ::com::mm::pb::po::ConName& ResultContacts::name() const {
  return name_ != NULL ? *name_ : *default_instance_->name_;
}
inline ::com::mm::pb::po::ConName* ResultContacts::mutable_name() {
  set_has_name();
  if (name_ == NULL) name_ = new ::com::mm::pb::po::ConName;
  return name_;
}
inline ::com::mm::pb::po::ConName* ResultContacts::release_name() {
  clear_has_name();
  ::com::mm::pb::po::ConName* temp = name_;
  name_ = NULL;
  return temp;
}
inline void ResultContacts::set_allocated_name(::com::mm::pb::po::ConName* name) {
  delete name_;
  name_ = name;
  if (name) {
    set_has_name();
  } else {
    clear_has_name();
  }
}

// -------------------------------------------------------------------

// MyVCard

// optional string username = 1;
inline bool MyVCard::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MyVCard::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MyVCard::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MyVCard::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& MyVCard::username() const {
  return *username_;
}
inline void MyVCard::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void MyVCard::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void MyVCard::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MyVCard::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* MyVCard::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MyVCard::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string phone = 2;
inline bool MyVCard::has_phone() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MyVCard::set_has_phone() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MyVCard::clear_has_phone() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MyVCard::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& MyVCard::phone() const {
  return *phone_;
}
inline void MyVCard::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void MyVCard::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void MyVCard::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MyVCard::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* MyVCard::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MyVCard::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string email = 3;
inline bool MyVCard::has_email() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MyVCard::set_has_email() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MyVCard::clear_has_email() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MyVCard::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& MyVCard::email() const {
  return *email_;
}
inline void MyVCard::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void MyVCard::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void MyVCard::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MyVCard::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* MyVCard::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MyVCard::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace po
}  // namespace pb
}  // namespace mm
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ContactsParamsPOJO_2eproto__INCLUDED
