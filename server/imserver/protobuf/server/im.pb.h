// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: im.proto

#ifndef PROTOBUF_im_2eproto__INCLUDED
#define PROTOBUF_im_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace im {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_im_2eproto();
void protobuf_AssignDesc_im_2eproto();
void protobuf_ShutdownFile_im_2eproto();

class im;
class im_imack;
class im_imchat;
class im_imclose;
class im_imlogin;
class im_imlogout;
class im_imupstream;
class im_imkeepalive;
class im_impgcreate;
class im_impginvite;
class im_impgquit;
class im_impgmodify;
class im_impgcard;
class im_imsns;
class im_imfansmodify;
class im_imfansappend;
class im_imfansdelete;
class im_immessage;
class im_immappoint;
class im_imdelete;
class im_imblacklist;

enum im_Type {
  im_Type_IM_ROOT = 0,
  im_Type_IM_ACK = 1,
  im_Type_IM_CHAT = 2,
  im_Type_IM_CLOSE = 3,
  im_Type_IM_LOGIN = 4,
  im_Type_IM_LOGOUT = 5,
  im_Type_IM_KICKOUT = 6,
  im_Type_IM_UPSTREAM = 7,
  im_Type_IM_KEEPALIVE = 8,
  im_Type_IM_PGCREATE = 9,
  im_Type_IM_PGINVITE = 10,
  im_Type_IM_PGQUIT = 11,
  im_Type_IM_PGMODIFY = 12,
  im_Type_IM_PGCARD = 13,
  im_Type_IM_SNS = 14,
  im_Type_IM_FANSMODIFY = 15,
  im_Type_IM_FANSAPPEND = 16,
  im_Type_IM_FANSDELETE = 17,
  im_Type_IM_MESSAGE = 18,
  im_Type_IM_MAPPOINT = 19,
  im_Type_IM_DELETE = 20,
  im_Type_IM_BLACKLIST = 21
};
bool im_Type_IsValid(int value);
const im_Type im_Type_Type_MIN = im_Type_IM_ROOT;
const im_Type im_Type_Type_MAX = im_Type_IM_BLACKLIST;
const int im_Type_Type_ARRAYSIZE = im_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* im_Type_descriptor();
inline const ::std::string& im_Type_Name(im_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    im_Type_descriptor(), value);
}
inline bool im_Type_Parse(
    const ::std::string& name, im_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<im_Type>(
    im_Type_descriptor(), name, value);
}
// ===================================================================

class im_imack : public ::google::protobuf::Message {
 public:
  im_imack();
  virtual ~im_imack();

  im_imack(const im_imack& from);

  inline im_imack& operator=(const im_imack& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const im_imack& default_instance();

  void Swap(im_imack* other);

  // implements Message ----------------------------------------------

  im_imack* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const im_imack& from);
  void MergeFrom(const im_imack& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string addr = 2;
  inline bool has_addr() const;
  inline void clear_addr();
  static const int kAddrFieldNumber = 2;
  inline const ::std::string& addr() const;
  inline void set_addr(const ::std::string& value);
  inline void set_addr(const char* value);
  inline void set_addr(const char* value, size_t size);
  inline ::std::string* mutable_addr();
  inline ::std::string* release_addr();
  inline void set_allocated_addr(::std::string* addr);

  // optional string time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:im.im.imack)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_addr();
  inline void clear_has_addr();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* addr_;
  ::std::string* time_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static im_imack* default_instance_;
};
// -------------------------------------------------------------------

class im_imchat : public ::google::protobuf::Message {
 public:
  im_imchat();
  virtual ~im_imchat();

  im_imchat(const im_imchat& from);

  inline im_imchat& operator=(const im_imchat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const im_imchat& default_instance();

  void Swap(im_imchat* other);

  // implements Message ----------------------------------------------

  im_imchat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const im_imchat& from);
  void MergeFrom(const im_imchat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string to = 2;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 2;
  inline const ::std::string& to() const;
  inline void set_to(const ::std::string& value);
  inline void set_to(const char* value);
  inline void set_to(const char* value, size_t size);
  inline ::std::string* mutable_to();
  inline ::std::string* release_to();
  inline void set_allocated_to(::std::string* to);

  // optional string addr = 3;
  inline bool has_addr() const;
  inline void clear_addr();
  static const int kAddrFieldNumber = 3;
  inline const ::std::string& addr() const;
  inline void set_addr(const ::std::string& value);
  inline void set_addr(const char* value);
  inline void set_addr(const char* value, size_t size);
  inline ::std::string* mutable_addr();
  inline ::std::string* release_addr();
  inline void set_allocated_addr(::std::string* addr);

  // optional string body = 4;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 4;
  inline const ::std::string& body() const;
  inline void set_body(const ::std::string& value);
  inline void set_body(const char* value);
  inline void set_body(const char* value, size_t size);
  inline ::std::string* mutable_body();
  inline ::std::string* release_body();
  inline void set_allocated_body(::std::string* body);

  // optional string from = 5;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 5;
  inline const ::std::string& from() const;
  inline void set_from(const ::std::string& value);
  inline void set_from(const char* value);
  inline void set_from(const char* value, size_t size);
  inline ::std::string* mutable_from();
  inline ::std::string* release_from();
  inline void set_allocated_from(::std::string* from);

  // optional string type = 6;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 6;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string category = 7;
  inline bool has_category() const;
  inline void clear_category();
  static const int kCategoryFieldNumber = 7;
  inline const ::std::string& category() const;
  inline void set_category(const ::std::string& value);
  inline void set_category(const char* value);
  inline void set_category(const char* value, size_t size);
  inline ::std::string* mutable_category();
  inline ::std::string* release_category();
  inline void set_allocated_category(::std::string* category);

  // optional string time = 8;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 8;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // optional int32 issave = 9;
  inline bool has_issave() const;
  inline void clear_issave();
  static const int kIssaveFieldNumber = 9;
  inline ::google::protobuf::int32 issave() const;
  inline void set_issave(::google::protobuf::int32 value);

  // optional int32 isshare = 10;
  inline bool has_isshare() const;
  inline void clear_isshare();
  static const int kIsshareFieldNumber = 10;
  inline ::google::protobuf::int32 isshare() const;
  inline void set_isshare(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:im.im.imchat)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_to();
  inline void clear_has_to();
  inline void set_has_addr();
  inline void clear_has_addr();
  inline void set_has_body();
  inline void clear_has_body();
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_category();
  inline void clear_has_category();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_issave();
  inline void clear_has_issave();
  inline void set_has_isshare();
  inline void clear_has_isshare();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* to_;
  ::std::string* addr_;
  ::std::string* body_;
  ::std::string* from_;
  ::std::string* type_;
  ::std::string* category_;
  ::std::string* time_;
  ::google::protobuf::int32 issave_;
  ::google::protobuf::int32 isshare_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static im_imchat* default_instance_;
};
// -------------------------------------------------------------------

class im_imclose : public ::google::protobuf::Message {
 public:
  im_imclose();
  virtual ~im_imclose();

  im_imclose(const im_imclose& from);

  inline im_imclose& operator=(const im_imclose& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const im_imclose& default_instance();

  void Swap(im_imclose* other);

  // implements Message ----------------------------------------------

  im_imclose* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const im_imclose& from);
  void MergeFrom(const im_imclose& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // required string addr = 2;
  inline bool has_addr() const;
  inline void clear_addr();
  static const int kAddrFieldNumber = 2;
  inline const ::std::string& addr() const;
  inline void set_addr(const ::std::string& value);
  inline void set_addr(const char* value);
  inline void set_addr(const char* value, size_t size);
  inline ::std::string* mutable_addr();
  inline ::std::string* release_addr();
  inline void set_allocated_addr(::std::string* addr);

  // @@protoc_insertion_point(class_scope:im.im.imclose)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_addr();
  inline void clear_has_addr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_;
  ::std::string* addr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static im_imclose* default_instance_;
};
// -------------------------------------------------------------------

class im_imlogin : public ::google::protobuf::Message {
 public:
  im_imlogin();
  virtual ~im_imlogin();

  im_imlogin(const im_imlogin& from);

  inline im_imlogin& operator=(const im_imlogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const im_imlogin& default_instance();

  void Swap(im_imlogin* other);

  // implements Message ----------------------------------------------

  im_imlogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const im_imlogin& from);
  void MergeFrom(const im_imlogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string from = 1;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 1;
  inline const ::std::string& from() const;
  inline void set_from(const ::std::string& value);
  inline void set_from(const char* value);
  inline void set_from(const char* value, size_t size);
  inline ::std::string* mutable_from();
  inline ::std::string* release_from();
  inline void set_allocated_from(::std::string* from);

  // optional string domain = 2;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 2;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // optional string platform = 3;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 3;
  inline const ::std::string& platform() const;
  inline void set_platform(const ::std::string& value);
  inline void set_platform(const char* value);
  inline void set_platform(const char* value, size_t size);
  inline ::std::string* mutable_platform();
  inline ::std::string* release_platform();
  inline void set_allocated_platform(::std::string* platform);

  // optional string resource = 4;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 4;
  inline const ::std::string& resource() const;
  inline void set_resource(const ::std::string& value);
  inline void set_resource(const char* value);
  inline void set_resource(const char* value, size_t size);
  inline ::std::string* mutable_resource();
  inline ::std::string* release_resource();
  inline void set_allocated_resource(::std::string* resource);

  // optional int32 status = 5;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 5;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:im.im.imlogin)
 private:
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_resource();
  inline void clear_has_resource();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* from_;
  ::std::string* domain_;
  ::std::string* platform_;
  ::std::string* resource_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static im_imlogin* default_instance_;
};
// -------------------------------------------------------------------

class im_imlogout : public ::google::protobuf::Message {
 public:
  im_imlogout();
  virtual ~im_imlogout();

  im_imlogout(const im_imlogout& from);

  inline im_imlogout& operator=(const im_imlogout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const im_imlogout& default_instance();

  void Swap(im_imlogout* other);

  // implements Message ----------------------------------------------

  im_imlogout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const im_imlogout& from);
  void MergeFrom(const im_imlogout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:im.im.imlogout)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static im_imlogout* default_instance_;
};
// -------------------------------------------------------------------

class im_imupstream : public ::google::protobuf::Message {
 public:
  im_imupstream();
  virtual ~im_imupstream();

  im_imupstream(const im_imupstream& from);

  inline im_imupstream& operator=(const im_imupstream& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const im_imupstream& default_instance();

  void Swap(im_imupstream* other);

  // implements Message ----------------------------------------------

  im_imupstream* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const im_imupstream& from);
  void MergeFrom(const im_imupstream& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string from = 1;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 1;
  inline const ::std::string& from() const;
  inline void set_from(const ::std::string& value);
  inline void set_from(const char* value);
  inline void set_from(const char* value, size_t size);
  inline ::std::string* mutable_from();
  inline ::std::string* release_from();
  inline void set_allocated_from(::std::string* from);

  // required string domain = 2;
  inline bool has_domain() const;
  inline void clear_domain();
  static const int kDomainFieldNumber = 2;
  inline const ::std::string& domain() const;
  inline void set_domain(const ::std::string& value);
  inline void set_domain(const char* value);
  inline void set_domain(const char* value, size_t size);
  inline ::std::string* mutable_domain();
  inline ::std::string* release_domain();
  inline void set_allocated_domain(::std::string* domain);

  // required string platform = 3;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 3;
  inline const ::std::string& platform() const;
  inline void set_platform(const ::std::string& value);
  inline void set_platform(const char* value);
  inline void set_platform(const char* value, size_t size);
  inline ::std::string* mutable_platform();
  inline ::std::string* release_platform();
  inline void set_allocated_platform(::std::string* platform);

  // required string resource = 4;
  inline bool has_resource() const;
  inline void clear_resource();
  static const int kResourceFieldNumber = 4;
  inline const ::std::string& resource() const;
  inline void set_resource(const ::std::string& value);
  inline void set_resource(const char* value);
  inline void set_resource(const char* value, size_t size);
  inline ::std::string* mutable_resource();
  inline ::std::string* release_resource();
  inline void set_allocated_resource(::std::string* resource);

  // @@protoc_insertion_point(class_scope:im.im.imupstream)
 private:
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_domain();
  inline void clear_has_domain();
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_resource();
  inline void clear_has_resource();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* from_;
  ::std::string* domain_;
  ::std::string* platform_;
  ::std::string* resource_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static im_imupstream* default_instance_;
};
// -------------------------------------------------------------------

class im_imkeepalive : public ::google::protobuf::Message {
 public:
  im_imkeepalive();
  virtual ~im_imkeepalive();

  im_imkeepalive(const im_imkeepalive& from);

  inline im_imkeepalive& operator=(const im_imkeepalive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const im_imkeepalive& default_instance();

  void Swap(im_imkeepalive* other);

  // implements Message ----------------------------------------------

  im_imkeepalive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const im_imkeepalive& from);
  void MergeFrom(const im_imkeepalive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // @@protoc_insertion_point(class_scope:im.im.imkeepalive)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static im_imkeepalive* default_instance_;
};
// -------------------------------------------------------------------

class im_impgcreate : public ::google::protobuf::Message {
 public:
  im_impgcreate();
  virtual ~im_impgcreate();

  im_impgcreate(const im_impgcreate& from);

  inline im_impgcreate& operator=(const im_impgcreate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const im_impgcreate& default_instance();

  void Swap(im_impgcreate* other);

  // implements Message ----------------------------------------------

  im_impgcreate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const im_impgcreate& from);
  void MergeFrom(const im_impgcreate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string gid = 2;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 2;
  inline const ::std::string& gid() const;
  inline void set_gid(const ::std::string& value);
  inline void set_gid(const char* value);
  inline void set_gid(const char* value, size_t size);
  inline ::std::string* mutable_gid();
  inline ::std::string* release_gid();
  inline void set_allocated_gid(::std::string* gid);

  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // required int32 type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:im.im.impgcreate)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* gid_;
  ::std::string* name_;
  ::std::string* time_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static im_impgcreate* default_instance_;
};
// -------------------------------------------------------------------

class im_impginvite : public ::google::protobuf::Message {
 public:
  im_impginvite();
  virtual ~im_impginvite();

  im_impginvite(const im_impginvite& from);

  inline im_impginvite& operator=(const im_impginvite& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const im_impginvite& default_instance();

  void Swap(im_impginvite* other);

  // implements Message ----------------------------------------------

  im_impginvite* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const im_impginvite& from);
  void MergeFrom(const im_impginvite& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string gid = 2;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 2;
  inline const ::std::string& gid() const;
  inline void set_gid(const ::std::string& value);
  inline void set_gid(const char* value);
  inline void set_gid(const char* value, size_t size);
  inline ::std::string* mutable_gid();
  inline ::std::string* release_gid();
  inline void set_allocated_gid(::std::string* gid);

  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // required string invites = 5;
  inline bool has_invites() const;
  inline void clear_invites();
  static const int kInvitesFieldNumber = 5;
  inline const ::std::string& invites() const;
  inline void set_invites(const ::std::string& value);
  inline void set_invites(const char* value);
  inline void set_invites(const char* value, size_t size);
  inline ::std::string* mutable_invites();
  inline ::std::string* release_invites();
  inline void set_allocated_invites(::std::string* invites);

  // required int32 type = 6;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 6;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:im.im.impginvite)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_invites();
  inline void clear_has_invites();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* gid_;
  ::std::string* name_;
  ::std::string* time_;
  ::std::string* invites_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static im_impginvite* default_instance_;
};
// -------------------------------------------------------------------

class im_impgquit : public ::google::protobuf::Message {
 public:
  im_impgquit();
  virtual ~im_impgquit();

  im_impgquit(const im_impgquit& from);

  inline im_impgquit& operator=(const im_impgquit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const im_impgquit& default_instance();

  void Swap(im_impgquit* other);

  // implements Message ----------------------------------------------

  im_impgquit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const im_impgquit& from);
  void MergeFrom(const im_impgquit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string gid = 2;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 2;
  inline const ::std::string& gid() const;
  inline void set_gid(const ::std::string& value);
  inline void set_gid(const char* value);
  inline void set_gid(const char* value, size_t size);
  inline ::std::string* mutable_gid();
  inline ::std::string* release_gid();
  inline void set_allocated_gid(::std::string* gid);

  // required string gkey = 3;
  inline bool has_gkey() const;
  inline void clear_gkey();
  static const int kGkeyFieldNumber = 3;
  inline const ::std::string& gkey() const;
  inline void set_gkey(const ::std::string& value);
  inline void set_gkey(const char* value);
  inline void set_gkey(const char* value, size_t size);
  inline ::std::string* mutable_gkey();
  inline ::std::string* release_gkey();
  inline void set_allocated_gkey(::std::string* gkey);

  // required string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string time = 5;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 5;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // required int32 type = 6;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 6;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required string uid = 7;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 7;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // @@protoc_insertion_point(class_scope:im.im.impgquit)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_gkey();
  inline void clear_has_gkey();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* gid_;
  ::std::string* gkey_;
  ::std::string* name_;
  ::std::string* time_;
  ::std::string* uid_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static im_impgquit* default_instance_;
};
// -------------------------------------------------------------------

class im_impgmodify : public ::google::protobuf::Message {
 public:
  im_impgmodify();
  virtual ~im_impgmodify();

  im_impgmodify(const im_impgmodify& from);

  inline im_impgmodify& operator=(const im_impgmodify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const im_impgmodify& default_instance();

  void Swap(im_impgmodify* other);

  // implements Message ----------------------------------------------

  im_impgmodify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const im_impgmodify& from);
  void MergeFrom(const im_impgmodify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string gid = 2;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 2;
  inline const ::std::string& gid() const;
  inline void set_gid(const ::std::string& value);
  inline void set_gid(const char* value);
  inline void set_gid(const char* value, size_t size);
  inline ::std::string* mutable_gid();
  inline ::std::string* release_gid();
  inline void set_allocated_gid(::std::string* gid);

  // required string gname = 3;
  inline bool has_gname() const;
  inline void clear_gname();
  static const int kGnameFieldNumber = 3;
  inline const ::std::string& gname() const;
  inline void set_gname(const ::std::string& value);
  inline void set_gname(const char* value);
  inline void set_gname(const char* value, size_t size);
  inline ::std::string* mutable_gname();
  inline ::std::string* release_gname();
  inline void set_allocated_gname(::std::string* gname);

  // required string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string time = 5;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 5;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // required int32 type = 6;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 6;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:im.im.impgmodify)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_gname();
  inline void clear_has_gname();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* gid_;
  ::std::string* gname_;
  ::std::string* name_;
  ::std::string* time_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static im_impgmodify* default_instance_;
};
// -------------------------------------------------------------------

class im_impgcard : public ::google::protobuf::Message {
 public:
  im_impgcard();
  virtual ~im_impgcard();

  im_impgcard(const im_impgcard& from);

  inline im_impgcard& operator=(const im_impgcard& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const im_impgcard& default_instance();

  void Swap(im_impgcard* other);

  // implements Message ----------------------------------------------

  im_impgcard* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const im_impgcard& from);
  void MergeFrom(const im_impgcard& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string gid = 2;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 2;
  inline const ::std::string& gid() const;
  inline void set_gid(const ::std::string& value);
  inline void set_gid(const char* value);
  inline void set_gid(const char* value, size_t size);
  inline ::std::string* mutable_gid();
  inline ::std::string* release_gid();
  inline void set_allocated_gid(::std::string* gid);

  // required string uid = 3;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 3;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // required string cardname = 4;
  inline bool has_cardname() const;
  inline void clear_cardname();
  static const int kCardnameFieldNumber = 4;
  inline const ::std::string& cardname() const;
  inline void set_cardname(const ::std::string& value);
  inline void set_cardname(const char* value);
  inline void set_cardname(const char* value, size_t size);
  inline ::std::string* mutable_cardname();
  inline ::std::string* release_cardname();
  inline void set_allocated_cardname(::std::string* cardname);

  // required string time = 5;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 5;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // @@protoc_insertion_point(class_scope:im.im.impgcard)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_cardname();
  inline void clear_has_cardname();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* gid_;
  ::std::string* uid_;
  ::std::string* cardname_;
  ::std::string* time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static im_impgcard* default_instance_;
};
// -------------------------------------------------------------------

class im_imsns : public ::google::protobuf::Message {
 public:
  im_imsns();
  virtual ~im_imsns();

  im_imsns(const im_imsns& from);

  inline im_imsns& operator=(const im_imsns& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const im_imsns& default_instance();

  void Swap(im_imsns* other);

  // implements Message ----------------------------------------------

  im_imsns* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const im_imsns& from);
  void MergeFrom(const im_imsns& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string subtype = 2;
  inline bool has_subtype() const;
  inline void clear_subtype();
  static const int kSubtypeFieldNumber = 2;
  inline const ::std::string& subtype() const;
  inline void set_subtype(const ::std::string& value);
  inline void set_subtype(const char* value);
  inline void set_subtype(const char* value, size_t size);
  inline ::std::string* mutable_subtype();
  inline ::std::string* release_subtype();
  inline void set_allocated_subtype(::std::string* subtype);

  // @@protoc_insertion_point(class_scope:im.im.imsns)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_subtype();
  inline void clear_has_subtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* subtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static im_imsns* default_instance_;
};
// -------------------------------------------------------------------

class im_imfansmodify : public ::google::protobuf::Message {
 public:
  im_imfansmodify();
  virtual ~im_imfansmodify();

  im_imfansmodify(const im_imfansmodify& from);

  inline im_imfansmodify& operator=(const im_imfansmodify& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const im_imfansmodify& default_instance();

  void Swap(im_imfansmodify* other);

  // implements Message ----------------------------------------------

  im_imfansmodify* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const im_imfansmodify& from);
  void MergeFrom(const im_imfansmodify& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string key = 4;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 4;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required string info = 5;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 5;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const char* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  inline void set_allocated_info(::std::string* info);

  // @@protoc_insertion_point(class_scope:im.im.imfansmodify)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_info();
  inline void clear_has_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* uid_;
  ::std::string* name_;
  ::std::string* key_;
  ::std::string* info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static im_imfansmodify* default_instance_;
};
// -------------------------------------------------------------------

class im_imfansappend : public ::google::protobuf::Message {
 public:
  im_imfansappend();
  virtual ~im_imfansappend();

  im_imfansappend(const im_imfansappend& from);

  inline im_imfansappend& operator=(const im_imfansappend& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const im_imfansappend& default_instance();

  void Swap(im_imfansappend* other);

  // implements Message ----------------------------------------------

  im_imfansappend* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const im_imfansappend& from);
  void MergeFrom(const im_imfansappend& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // required string key = 3;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 3;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required string time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // required string subtype = 5;
  inline bool has_subtype() const;
  inline void clear_subtype();
  static const int kSubtypeFieldNumber = 5;
  inline const ::std::string& subtype() const;
  inline void set_subtype(const ::std::string& value);
  inline void set_subtype(const char* value);
  inline void set_subtype(const char* value, size_t size);
  inline ::std::string* mutable_subtype();
  inline ::std::string* release_subtype();
  inline void set_allocated_subtype(::std::string* subtype);

  // required string name = 6;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 6;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string info = 7;
  inline bool has_info() const;
  inline void clear_info();
  static const int kInfoFieldNumber = 7;
  inline const ::std::string& info() const;
  inline void set_info(const ::std::string& value);
  inline void set_info(const char* value);
  inline void set_info(const char* value, size_t size);
  inline ::std::string* mutable_info();
  inline ::std::string* release_info();
  inline void set_allocated_info(::std::string* info);

  // required string cmsid = 8;
  inline bool has_cmsid() const;
  inline void clear_cmsid();
  static const int kCmsidFieldNumber = 8;
  inline const ::std::string& cmsid() const;
  inline void set_cmsid(const ::std::string& value);
  inline void set_cmsid(const char* value);
  inline void set_cmsid(const char* value, size_t size);
  inline ::std::string* mutable_cmsid();
  inline ::std::string* release_cmsid();
  inline void set_allocated_cmsid(::std::string* cmsid);

  // @@protoc_insertion_point(class_scope:im.im.imfansappend)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_subtype();
  inline void clear_has_subtype();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_info();
  inline void clear_has_info();
  inline void set_has_cmsid();
  inline void clear_has_cmsid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* uid_;
  ::std::string* key_;
  ::std::string* time_;
  ::std::string* subtype_;
  ::std::string* name_;
  ::std::string* info_;
  ::std::string* cmsid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static im_imfansappend* default_instance_;
};
// -------------------------------------------------------------------

class im_imfansdelete : public ::google::protobuf::Message {
 public:
  im_imfansdelete();
  virtual ~im_imfansdelete();

  im_imfansdelete(const im_imfansdelete& from);

  inline im_imfansdelete& operator=(const im_imfansdelete& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const im_imfansdelete& default_instance();

  void Swap(im_imfansdelete* other);

  // implements Message ----------------------------------------------

  im_imfansdelete* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const im_imfansdelete& from);
  void MergeFrom(const im_imfansdelete& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline const ::std::string& uid() const;
  inline void set_uid(const ::std::string& value);
  inline void set_uid(const char* value);
  inline void set_uid(const char* value, size_t size);
  inline ::std::string* mutable_uid();
  inline ::std::string* release_uid();
  inline void set_allocated_uid(::std::string* uid);

  // required string time = 3;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 3;
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline void set_time(const char* value, size_t size);
  inline ::std::string* mutable_time();
  inline ::std::string* release_time();
  inline void set_allocated_time(::std::string* time);

  // @@protoc_insertion_point(class_scope:im.im.imfansdelete)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* uid_;
  ::std::string* time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static im_imfansdelete* default_instance_;
};
// -------------------------------------------------------------------

class im_immessage : public ::google::protobuf::Message {
 public:
  im_immessage();
  virtual ~im_immessage();

  im_immessage(const im_immessage& from);

  inline im_immessage& operator=(const im_immessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const im_immessage& default_instance();

  void Swap(im_immessage* other);

  // implements Message ----------------------------------------------

  im_immessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const im_immessage& from);
  void MergeFrom(const im_immessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string touser = 2;
  inline bool has_touser() const;
  inline void clear_touser();
  static const int kTouserFieldNumber = 2;
  inline const ::std::string& touser() const;
  inline void set_touser(const ::std::string& value);
  inline void set_touser(const char* value);
  inline void set_touser(const char* value, size_t size);
  inline ::std::string* mutable_touser();
  inline ::std::string* release_touser();
  inline void set_allocated_touser(::std::string* touser);

  // required string msgtype = 3;
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgtypeFieldNumber = 3;
  inline const ::std::string& msgtype() const;
  inline void set_msgtype(const ::std::string& value);
  inline void set_msgtype(const char* value);
  inline void set_msgtype(const char* value, size_t size);
  inline ::std::string* mutable_msgtype();
  inline ::std::string* release_msgtype();
  inline void set_allocated_msgtype(::std::string* msgtype);

  // required string fromuser = 4;
  inline bool has_fromuser() const;
  inline void clear_fromuser();
  static const int kFromuserFieldNumber = 4;
  inline const ::std::string& fromuser() const;
  inline void set_fromuser(const ::std::string& value);
  inline void set_fromuser(const char* value);
  inline void set_fromuser(const char* value, size_t size);
  inline ::std::string* mutable_fromuser();
  inline ::std::string* release_fromuser();
  inline void set_allocated_fromuser(::std::string* fromuser);

  // required string category = 5;
  inline bool has_category() const;
  inline void clear_category();
  static const int kCategoryFieldNumber = 5;
  inline const ::std::string& category() const;
  inline void set_category(const ::std::string& value);
  inline void set_category(const char* value);
  inline void set_category(const char* value, size_t size);
  inline ::std::string* mutable_category();
  inline ::std::string* release_category();
  inline void set_allocated_category(::std::string* category);

  // required string imagekey = 6;
  inline bool has_imagekey() const;
  inline void clear_imagekey();
  static const int kImagekeyFieldNumber = 6;
  inline const ::std::string& imagekey() const;
  inline void set_imagekey(const ::std::string& value);
  inline void set_imagekey(const char* value);
  inline void set_imagekey(const char* value, size_t size);
  inline ::std::string* mutable_imagekey();
  inline ::std::string* release_imagekey();
  inline void set_allocated_imagekey(::std::string* imagekey);

  // required string txtbuffer = 7;
  inline bool has_txtbuffer() const;
  inline void clear_txtbuffer();
  static const int kTxtbufferFieldNumber = 7;
  inline const ::std::string& txtbuffer() const;
  inline void set_txtbuffer(const ::std::string& value);
  inline void set_txtbuffer(const char* value);
  inline void set_txtbuffer(const char* value, size_t size);
  inline ::std::string* mutable_txtbuffer();
  inline ::std::string* release_txtbuffer();
  inline void set_allocated_txtbuffer(::std::string* txtbuffer);

  // optional string imagewidth = 8;
  inline bool has_imagewidth() const;
  inline void clear_imagewidth();
  static const int kImagewidthFieldNumber = 8;
  inline const ::std::string& imagewidth() const;
  inline void set_imagewidth(const ::std::string& value);
  inline void set_imagewidth(const char* value);
  inline void set_imagewidth(const char* value, size_t size);
  inline ::std::string* mutable_imagewidth();
  inline ::std::string* release_imagewidth();
  inline void set_allocated_imagewidth(::std::string* imagewidth);

  // optional string imageheight = 9;
  inline bool has_imageheight() const;
  inline void clear_imageheight();
  static const int kImageheightFieldNumber = 9;
  inline const ::std::string& imageheight() const;
  inline void set_imageheight(const ::std::string& value);
  inline void set_imageheight(const char* value);
  inline void set_imageheight(const char* value, size_t size);
  inline ::std::string* mutable_imageheight();
  inline ::std::string* release_imageheight();
  inline void set_allocated_imageheight(::std::string* imageheight);

  // optional string videolength = 10;
  inline bool has_videolength() const;
  inline void clear_videolength();
  static const int kVideolengthFieldNumber = 10;
  inline const ::std::string& videolength() const;
  inline void set_videolength(const ::std::string& value);
  inline void set_videolength(const char* value);
  inline void set_videolength(const char* value, size_t size);
  inline ::std::string* mutable_videolength();
  inline ::std::string* release_videolength();
  inline void set_allocated_videolength(::std::string* videolength);

  // optional string videokey = 11;
  inline bool has_videokey() const;
  inline void clear_videokey();
  static const int kVideokeyFieldNumber = 11;
  inline const ::std::string& videokey() const;
  inline void set_videokey(const ::std::string& value);
  inline void set_videokey(const char* value);
  inline void set_videokey(const char* value, size_t size);
  inline ::std::string* mutable_videokey();
  inline ::std::string* release_videokey();
  inline void set_allocated_videokey(::std::string* videokey);

  // optional string videotitle = 12;
  inline bool has_videotitle() const;
  inline void clear_videotitle();
  static const int kVideotitleFieldNumber = 12;
  inline const ::std::string& videotitle() const;
  inline void set_videotitle(const ::std::string& value);
  inline void set_videotitle(const char* value);
  inline void set_videotitle(const char* value, size_t size);
  inline ::std::string* mutable_videotitle();
  inline ::std::string* release_videotitle();
  inline void set_allocated_videotitle(::std::string* videotitle);

  // @@protoc_insertion_point(class_scope:im.im.immessage)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_touser();
  inline void clear_has_touser();
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_fromuser();
  inline void clear_has_fromuser();
  inline void set_has_category();
  inline void clear_has_category();
  inline void set_has_imagekey();
  inline void clear_has_imagekey();
  inline void set_has_txtbuffer();
  inline void clear_has_txtbuffer();
  inline void set_has_imagewidth();
  inline void clear_has_imagewidth();
  inline void set_has_imageheight();
  inline void clear_has_imageheight();
  inline void set_has_videolength();
  inline void clear_has_videolength();
  inline void set_has_videokey();
  inline void clear_has_videokey();
  inline void set_has_videotitle();
  inline void clear_has_videotitle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* touser_;
  ::std::string* msgtype_;
  ::std::string* fromuser_;
  ::std::string* category_;
  ::std::string* imagekey_;
  ::std::string* txtbuffer_;
  ::std::string* imagewidth_;
  ::std::string* imageheight_;
  ::std::string* videolength_;
  ::std::string* videokey_;
  ::std::string* videotitle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static im_immessage* default_instance_;
};
// -------------------------------------------------------------------

class im_immappoint : public ::google::protobuf::Message {
 public:
  im_immappoint();
  virtual ~im_immappoint();

  im_immappoint(const im_immappoint& from);

  inline im_immappoint& operator=(const im_immappoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const im_immappoint& default_instance();

  void Swap(im_immappoint* other);

  // implements Message ----------------------------------------------

  im_immappoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const im_immappoint& from);
  void MergeFrom(const im_immappoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string xpoint = 1;
  inline bool has_xpoint() const;
  inline void clear_xpoint();
  static const int kXpointFieldNumber = 1;
  inline const ::std::string& xpoint() const;
  inline void set_xpoint(const ::std::string& value);
  inline void set_xpoint(const char* value);
  inline void set_xpoint(const char* value, size_t size);
  inline ::std::string* mutable_xpoint();
  inline ::std::string* release_xpoint();
  inline void set_allocated_xpoint(::std::string* xpoint);

  // required string ypoint = 2;
  inline bool has_ypoint() const;
  inline void clear_ypoint();
  static const int kYpointFieldNumber = 2;
  inline const ::std::string& ypoint() const;
  inline void set_ypoint(const ::std::string& value);
  inline void set_ypoint(const char* value);
  inline void set_ypoint(const char* value, size_t size);
  inline ::std::string* mutable_ypoint();
  inline ::std::string* release_ypoint();
  inline void set_allocated_ypoint(::std::string* ypoint);

  // @@protoc_insertion_point(class_scope:im.im.immappoint)
 private:
  inline void set_has_xpoint();
  inline void clear_has_xpoint();
  inline void set_has_ypoint();
  inline void clear_has_ypoint();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* xpoint_;
  ::std::string* ypoint_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static im_immappoint* default_instance_;
};
// -------------------------------------------------------------------

class im_imdelete : public ::google::protobuf::Message {
 public:
  im_imdelete();
  virtual ~im_imdelete();

  im_imdelete(const im_imdelete& from);

  inline im_imdelete& operator=(const im_imdelete& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const im_imdelete& default_instance();

  void Swap(im_imdelete* other);

  // implements Message ----------------------------------------------

  im_imdelete* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const im_imdelete& from);
  void MergeFrom(const im_imdelete& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string msgid = 1;
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgidFieldNumber = 1;
  inline const ::std::string& msgid() const;
  inline void set_msgid(const ::std::string& value);
  inline void set_msgid(const char* value);
  inline void set_msgid(const char* value, size_t size);
  inline ::std::string* mutable_msgid();
  inline ::std::string* release_msgid();
  inline void set_allocated_msgid(::std::string* msgid);

  // required string imagekey = 2;
  inline bool has_imagekey() const;
  inline void clear_imagekey();
  static const int kImagekeyFieldNumber = 2;
  inline const ::std::string& imagekey() const;
  inline void set_imagekey(const ::std::string& value);
  inline void set_imagekey(const char* value);
  inline void set_imagekey(const char* value, size_t size);
  inline ::std::string* mutable_imagekey();
  inline ::std::string* release_imagekey();
  inline void set_allocated_imagekey(::std::string* imagekey);

  // required string videokey = 3;
  inline bool has_videokey() const;
  inline void clear_videokey();
  static const int kVideokeyFieldNumber = 3;
  inline const ::std::string& videokey() const;
  inline void set_videokey(const ::std::string& value);
  inline void set_videokey(const char* value);
  inline void set_videokey(const char* value, size_t size);
  inline ::std::string* mutable_videokey();
  inline ::std::string* release_videokey();
  inline void set_allocated_videokey(::std::string* videokey);

  // @@protoc_insertion_point(class_scope:im.im.imdelete)
 private:
  inline void set_has_msgid();
  inline void clear_has_msgid();
  inline void set_has_imagekey();
  inline void clear_has_imagekey();
  inline void set_has_videokey();
  inline void clear_has_videokey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgid_;
  ::std::string* imagekey_;
  ::std::string* videokey_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static im_imdelete* default_instance_;
};
// -------------------------------------------------------------------

class im_imblacklist : public ::google::protobuf::Message {
 public:
  im_imblacklist();
  virtual ~im_imblacklist();

  im_imblacklist(const im_imblacklist& from);

  inline im_imblacklist& operator=(const im_imblacklist& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const im_imblacklist& default_instance();

  void Swap(im_imblacklist* other);

  // implements Message ----------------------------------------------

  im_imblacklist* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const im_imblacklist& from);
  void MergeFrom(const im_imblacklist& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required string blackid = 2;
  inline bool has_blackid() const;
  inline void clear_blackid();
  static const int kBlackidFieldNumber = 2;
  inline const ::std::string& blackid() const;
  inline void set_blackid(const ::std::string& value);
  inline void set_blackid(const char* value);
  inline void set_blackid(const char* value, size_t size);
  inline ::std::string* mutable_blackid();
  inline ::std::string* release_blackid();
  inline void set_allocated_blackid(::std::string* blackid);

  // @@protoc_insertion_point(class_scope:im.im.imblacklist)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_blackid();
  inline void clear_has_blackid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* blackid_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static im_imblacklist* default_instance_;
};
// -------------------------------------------------------------------

class im : public ::google::protobuf::Message {
 public:
  im();
  virtual ~im();

  im(const im& from);

  inline im& operator=(const im& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const im& default_instance();

  void Swap(im* other);

  // implements Message ----------------------------------------------

  im* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const im& from);
  void MergeFrom(const im& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef im_imack imack;
  typedef im_imchat imchat;
  typedef im_imclose imclose;
  typedef im_imlogin imlogin;
  typedef im_imlogout imlogout;
  typedef im_imupstream imupstream;
  typedef im_imkeepalive imkeepalive;
  typedef im_impgcreate impgcreate;
  typedef im_impginvite impginvite;
  typedef im_impgquit impgquit;
  typedef im_impgmodify impgmodify;
  typedef im_impgcard impgcard;
  typedef im_imsns imsns;
  typedef im_imfansmodify imfansmodify;
  typedef im_imfansappend imfansappend;
  typedef im_imfansdelete imfansdelete;
  typedef im_immessage immessage;
  typedef im_immappoint immappoint;
  typedef im_imdelete imdelete;
  typedef im_imblacklist imblacklist;

  typedef im_Type Type;
  static const Type IM_ROOT = im_Type_IM_ROOT;
  static const Type IM_ACK = im_Type_IM_ACK;
  static const Type IM_CHAT = im_Type_IM_CHAT;
  static const Type IM_CLOSE = im_Type_IM_CLOSE;
  static const Type IM_LOGIN = im_Type_IM_LOGIN;
  static const Type IM_LOGOUT = im_Type_IM_LOGOUT;
  static const Type IM_KICKOUT = im_Type_IM_KICKOUT;
  static const Type IM_UPSTREAM = im_Type_IM_UPSTREAM;
  static const Type IM_KEEPALIVE = im_Type_IM_KEEPALIVE;
  static const Type IM_PGCREATE = im_Type_IM_PGCREATE;
  static const Type IM_PGINVITE = im_Type_IM_PGINVITE;
  static const Type IM_PGQUIT = im_Type_IM_PGQUIT;
  static const Type IM_PGMODIFY = im_Type_IM_PGMODIFY;
  static const Type IM_PGCARD = im_Type_IM_PGCARD;
  static const Type IM_SNS = im_Type_IM_SNS;
  static const Type IM_FANSMODIFY = im_Type_IM_FANSMODIFY;
  static const Type IM_FANSAPPEND = im_Type_IM_FANSAPPEND;
  static const Type IM_FANSDELETE = im_Type_IM_FANSDELETE;
  static const Type IM_MESSAGE = im_Type_IM_MESSAGE;
  static const Type IM_MAPPOINT = im_Type_IM_MAPPOINT;
  static const Type IM_DELETE = im_Type_IM_DELETE;
  static const Type IM_BLACKLIST = im_Type_IM_BLACKLIST;
  static inline bool Type_IsValid(int value) {
    return im_Type_IsValid(value);
  }
  static const Type Type_MIN =
    im_Type_Type_MIN;
  static const Type Type_MAX =
    im_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    im_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return im_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return im_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return im_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .im.im.Type msgtype = 1 [default = IM_ROOT];
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgtypeFieldNumber = 1;
  inline ::im::im_Type msgtype() const;
  inline void set_msgtype(::im::im_Type value);

  // optional .im.im.imack ack = 2;
  inline bool has_ack() const;
  inline void clear_ack();
  static const int kAckFieldNumber = 2;
  inline const ::im::im_imack& ack() const;
  inline ::im::im_imack* mutable_ack();
  inline ::im::im_imack* release_ack();
  inline void set_allocated_ack(::im::im_imack* ack);

  // optional .im.im.imchat chat = 3;
  inline bool has_chat() const;
  inline void clear_chat();
  static const int kChatFieldNumber = 3;
  inline const ::im::im_imchat& chat() const;
  inline ::im::im_imchat* mutable_chat();
  inline ::im::im_imchat* release_chat();
  inline void set_allocated_chat(::im::im_imchat* chat);

  // optional .im.im.imclose close = 4;
  inline bool has_close() const;
  inline void clear_close();
  static const int kCloseFieldNumber = 4;
  inline const ::im::im_imclose& close() const;
  inline ::im::im_imclose* mutable_close();
  inline ::im::im_imclose* release_close();
  inline void set_allocated_close(::im::im_imclose* close);

  // optional .im.im.imlogin login = 5;
  inline bool has_login() const;
  inline void clear_login();
  static const int kLoginFieldNumber = 5;
  inline const ::im::im_imlogin& login() const;
  inline ::im::im_imlogin* mutable_login();
  inline ::im::im_imlogin* release_login();
  inline void set_allocated_login(::im::im_imlogin* login);

  // optional .im.im.imlogout logout = 6;
  inline bool has_logout() const;
  inline void clear_logout();
  static const int kLogoutFieldNumber = 6;
  inline const ::im::im_imlogout& logout() const;
  inline ::im::im_imlogout* mutable_logout();
  inline ::im::im_imlogout* release_logout();
  inline void set_allocated_logout(::im::im_imlogout* logout);

  // optional .im.im.imupstream upstream = 7;
  inline bool has_upstream() const;
  inline void clear_upstream();
  static const int kUpstreamFieldNumber = 7;
  inline const ::im::im_imupstream& upstream() const;
  inline ::im::im_imupstream* mutable_upstream();
  inline ::im::im_imupstream* release_upstream();
  inline void set_allocated_upstream(::im::im_imupstream* upstream);

  // optional .im.im.imkeepalive keepalive = 8;
  inline bool has_keepalive() const;
  inline void clear_keepalive();
  static const int kKeepaliveFieldNumber = 8;
  inline const ::im::im_imkeepalive& keepalive() const;
  inline ::im::im_imkeepalive* mutable_keepalive();
  inline ::im::im_imkeepalive* release_keepalive();
  inline void set_allocated_keepalive(::im::im_imkeepalive* keepalive);

  // optional .im.im.impgcreate pgcreate = 9;
  inline bool has_pgcreate() const;
  inline void clear_pgcreate();
  static const int kPgcreateFieldNumber = 9;
  inline const ::im::im_impgcreate& pgcreate() const;
  inline ::im::im_impgcreate* mutable_pgcreate();
  inline ::im::im_impgcreate* release_pgcreate();
  inline void set_allocated_pgcreate(::im::im_impgcreate* pgcreate);

  // optional .im.im.impginvite pginvite = 10;
  inline bool has_pginvite() const;
  inline void clear_pginvite();
  static const int kPginviteFieldNumber = 10;
  inline const ::im::im_impginvite& pginvite() const;
  inline ::im::im_impginvite* mutable_pginvite();
  inline ::im::im_impginvite* release_pginvite();
  inline void set_allocated_pginvite(::im::im_impginvite* pginvite);

  // optional .im.im.impgquit pgquit = 11;
  inline bool has_pgquit() const;
  inline void clear_pgquit();
  static const int kPgquitFieldNumber = 11;
  inline const ::im::im_impgquit& pgquit() const;
  inline ::im::im_impgquit* mutable_pgquit();
  inline ::im::im_impgquit* release_pgquit();
  inline void set_allocated_pgquit(::im::im_impgquit* pgquit);

  // optional .im.im.impgmodify pgmodify = 12;
  inline bool has_pgmodify() const;
  inline void clear_pgmodify();
  static const int kPgmodifyFieldNumber = 12;
  inline const ::im::im_impgmodify& pgmodify() const;
  inline ::im::im_impgmodify* mutable_pgmodify();
  inline ::im::im_impgmodify* release_pgmodify();
  inline void set_allocated_pgmodify(::im::im_impgmodify* pgmodify);

  // optional .im.im.impgcard pgcard = 13;
  inline bool has_pgcard() const;
  inline void clear_pgcard();
  static const int kPgcardFieldNumber = 13;
  inline const ::im::im_impgcard& pgcard() const;
  inline ::im::im_impgcard* mutable_pgcard();
  inline ::im::im_impgcard* release_pgcard();
  inline void set_allocated_pgcard(::im::im_impgcard* pgcard);

  // optional .im.im.imsns sns = 14;
  inline bool has_sns() const;
  inline void clear_sns();
  static const int kSnsFieldNumber = 14;
  inline const ::im::im_imsns& sns() const;
  inline ::im::im_imsns* mutable_sns();
  inline ::im::im_imsns* release_sns();
  inline void set_allocated_sns(::im::im_imsns* sns);

  // optional .im.im.imfansmodify fansmodify = 15;
  inline bool has_fansmodify() const;
  inline void clear_fansmodify();
  static const int kFansmodifyFieldNumber = 15;
  inline const ::im::im_imfansmodify& fansmodify() const;
  inline ::im::im_imfansmodify* mutable_fansmodify();
  inline ::im::im_imfansmodify* release_fansmodify();
  inline void set_allocated_fansmodify(::im::im_imfansmodify* fansmodify);

  // optional .im.im.imfansappend fansappend = 16;
  inline bool has_fansappend() const;
  inline void clear_fansappend();
  static const int kFansappendFieldNumber = 16;
  inline const ::im::im_imfansappend& fansappend() const;
  inline ::im::im_imfansappend* mutable_fansappend();
  inline ::im::im_imfansappend* release_fansappend();
  inline void set_allocated_fansappend(::im::im_imfansappend* fansappend);

  // optional .im.im.imfansdelete fansdelete = 17;
  inline bool has_fansdelete() const;
  inline void clear_fansdelete();
  static const int kFansdeleteFieldNumber = 17;
  inline const ::im::im_imfansdelete& fansdelete() const;
  inline ::im::im_imfansdelete* mutable_fansdelete();
  inline ::im::im_imfansdelete* release_fansdelete();
  inline void set_allocated_fansdelete(::im::im_imfansdelete* fansdelete);

  // optional .im.im.immessage message = 18;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 18;
  inline const ::im::im_immessage& message() const;
  inline ::im::im_immessage* mutable_message();
  inline ::im::im_immessage* release_message();
  inline void set_allocated_message(::im::im_immessage* message);

  // optional .im.im.immappoint mappoint = 19;
  inline bool has_mappoint() const;
  inline void clear_mappoint();
  static const int kMappointFieldNumber = 19;
  inline const ::im::im_immappoint& mappoint() const;
  inline ::im::im_immappoint* mutable_mappoint();
  inline ::im::im_immappoint* release_mappoint();
  inline void set_allocated_mappoint(::im::im_immappoint* mappoint);

  // optional .im.im.imdelete delete_ = 20;
  inline bool has_delete_() const;
  inline void clear_delete_();
  static const int kDeleteFieldNumber = 20;
  inline const ::im::im_imdelete& delete_() const;
  inline ::im::im_imdelete* mutable_delete_();
  inline ::im::im_imdelete* release_delete_();
  inline void set_allocated_delete_(::im::im_imdelete* delete_);

  // optional .im.im.imblacklist blacklist_ = 21;
  inline bool has_blacklist_() const;
  inline void clear_blacklist_();
  static const int kBlacklistFieldNumber = 21;
  inline const ::im::im_imblacklist& blacklist_() const;
  inline ::im::im_imblacklist* mutable_blacklist_();
  inline ::im::im_imblacklist* release_blacklist_();
  inline void set_allocated_blacklist_(::im::im_imblacklist* blacklist_);

  // @@protoc_insertion_point(class_scope:im.im)
 private:
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_ack();
  inline void clear_has_ack();
  inline void set_has_chat();
  inline void clear_has_chat();
  inline void set_has_close();
  inline void clear_has_close();
  inline void set_has_login();
  inline void clear_has_login();
  inline void set_has_logout();
  inline void clear_has_logout();
  inline void set_has_upstream();
  inline void clear_has_upstream();
  inline void set_has_keepalive();
  inline void clear_has_keepalive();
  inline void set_has_pgcreate();
  inline void clear_has_pgcreate();
  inline void set_has_pginvite();
  inline void clear_has_pginvite();
  inline void set_has_pgquit();
  inline void clear_has_pgquit();
  inline void set_has_pgmodify();
  inline void clear_has_pgmodify();
  inline void set_has_pgcard();
  inline void clear_has_pgcard();
  inline void set_has_sns();
  inline void clear_has_sns();
  inline void set_has_fansmodify();
  inline void clear_has_fansmodify();
  inline void set_has_fansappend();
  inline void clear_has_fansappend();
  inline void set_has_fansdelete();
  inline void clear_has_fansdelete();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_mappoint();
  inline void clear_has_mappoint();
  inline void set_has_delete_();
  inline void clear_has_delete_();
  inline void set_has_blacklist_();
  inline void clear_has_blacklist_();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::im::im_imack* ack_;
  ::im::im_imchat* chat_;
  ::im::im_imclose* close_;
  ::im::im_imlogin* login_;
  ::im::im_imlogout* logout_;
  ::im::im_imupstream* upstream_;
  ::im::im_imkeepalive* keepalive_;
  ::im::im_impgcreate* pgcreate_;
  ::im::im_impginvite* pginvite_;
  ::im::im_impgquit* pgquit_;
  ::im::im_impgmodify* pgmodify_;
  ::im::im_impgcard* pgcard_;
  ::im::im_imsns* sns_;
  ::im::im_imfansmodify* fansmodify_;
  ::im::im_imfansappend* fansappend_;
  ::im::im_imfansdelete* fansdelete_;
  ::im::im_immessage* message_;
  ::im::im_immappoint* mappoint_;
  ::im::im_imdelete* delete__;
  ::im::im_imblacklist* blacklist__;
  int msgtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];

  friend void  protobuf_AddDesc_im_2eproto();
  friend void protobuf_AssignDesc_im_2eproto();
  friend void protobuf_ShutdownFile_im_2eproto();

  void InitAsDefaultInstance();
  static im* default_instance_;
};
// ===================================================================


// ===================================================================

// im_imack

// required string id = 1;
inline bool im_imack::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void im_imack::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void im_imack::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void im_imack::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& im_imack::id() const {
  return *id_;
}
inline void im_imack::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void im_imack::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void im_imack::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imack::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* im_imack::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imack::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string addr = 2;
inline bool im_imack::has_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void im_imack::set_has_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void im_imack::clear_has_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void im_imack::clear_addr() {
  if (addr_ != &::google::protobuf::internal::kEmptyString) {
    addr_->clear();
  }
  clear_has_addr();
}
inline const ::std::string& im_imack::addr() const {
  return *addr_;
}
inline void im_imack::set_addr(const ::std::string& value) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(value);
}
inline void im_imack::set_addr(const char* value) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(value);
}
inline void im_imack::set_addr(const char* value, size_t size) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imack::mutable_addr() {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  return addr_;
}
inline ::std::string* im_imack::release_addr() {
  clear_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = addr_;
    addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imack::set_allocated_addr(::std::string* addr) {
  if (addr_ != &::google::protobuf::internal::kEmptyString) {
    delete addr_;
  }
  if (addr) {
    set_has_addr();
    addr_ = addr;
  } else {
    clear_has_addr();
    addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string time = 3;
inline bool im_imack::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void im_imack::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void im_imack::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void im_imack::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& im_imack::time() const {
  return *time_;
}
inline void im_imack::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void im_imack::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void im_imack::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imack::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* im_imack::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imack::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 4;
inline bool im_imack::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void im_imack::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void im_imack::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void im_imack::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& im_imack::name() const {
  return *name_;
}
inline void im_imack::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void im_imack::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void im_imack::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imack::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* im_imack::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imack::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// im_imchat

// required string id = 1;
inline bool im_imchat::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void im_imchat::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void im_imchat::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void im_imchat::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& im_imchat::id() const {
  return *id_;
}
inline void im_imchat::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void im_imchat::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void im_imchat::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imchat::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* im_imchat::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imchat::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string to = 2;
inline bool im_imchat::has_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void im_imchat::set_has_to() {
  _has_bits_[0] |= 0x00000002u;
}
inline void im_imchat::clear_has_to() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void im_imchat::clear_to() {
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    to_->clear();
  }
  clear_has_to();
}
inline const ::std::string& im_imchat::to() const {
  return *to_;
}
inline void im_imchat::set_to(const ::std::string& value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(value);
}
inline void im_imchat::set_to(const char* value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(value);
}
inline void im_imchat::set_to(const char* value, size_t size) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imchat::mutable_to() {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  return to_;
}
inline ::std::string* im_imchat::release_to() {
  clear_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_;
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imchat::set_allocated_to(::std::string* to) {
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    delete to_;
  }
  if (to) {
    set_has_to();
    to_ = to;
  } else {
    clear_has_to();
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string addr = 3;
inline bool im_imchat::has_addr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void im_imchat::set_has_addr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void im_imchat::clear_has_addr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void im_imchat::clear_addr() {
  if (addr_ != &::google::protobuf::internal::kEmptyString) {
    addr_->clear();
  }
  clear_has_addr();
}
inline const ::std::string& im_imchat::addr() const {
  return *addr_;
}
inline void im_imchat::set_addr(const ::std::string& value) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(value);
}
inline void im_imchat::set_addr(const char* value) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(value);
}
inline void im_imchat::set_addr(const char* value, size_t size) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imchat::mutable_addr() {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  return addr_;
}
inline ::std::string* im_imchat::release_addr() {
  clear_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = addr_;
    addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imchat::set_allocated_addr(::std::string* addr) {
  if (addr_ != &::google::protobuf::internal::kEmptyString) {
    delete addr_;
  }
  if (addr) {
    set_has_addr();
    addr_ = addr;
  } else {
    clear_has_addr();
    addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string body = 4;
inline bool im_imchat::has_body() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void im_imchat::set_has_body() {
  _has_bits_[0] |= 0x00000008u;
}
inline void im_imchat::clear_has_body() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void im_imchat::clear_body() {
  if (body_ != &::google::protobuf::internal::kEmptyString) {
    body_->clear();
  }
  clear_has_body();
}
inline const ::std::string& im_imchat::body() const {
  return *body_;
}
inline void im_imchat::set_body(const ::std::string& value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  body_->assign(value);
}
inline void im_imchat::set_body(const char* value) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  body_->assign(value);
}
inline void im_imchat::set_body(const char* value, size_t size) {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  body_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imchat::mutable_body() {
  set_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    body_ = new ::std::string;
  }
  return body_;
}
inline ::std::string* im_imchat::release_body() {
  clear_has_body();
  if (body_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = body_;
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imchat::set_allocated_body(::std::string* body) {
  if (body_ != &::google::protobuf::internal::kEmptyString) {
    delete body_;
  }
  if (body) {
    set_has_body();
    body_ = body;
  } else {
    clear_has_body();
    body_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string from = 5;
inline bool im_imchat::has_from() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void im_imchat::set_has_from() {
  _has_bits_[0] |= 0x00000010u;
}
inline void im_imchat::clear_has_from() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void im_imchat::clear_from() {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    from_->clear();
  }
  clear_has_from();
}
inline const ::std::string& im_imchat::from() const {
  return *from_;
}
inline void im_imchat::set_from(const ::std::string& value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void im_imchat::set_from(const char* value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void im_imchat::set_from(const char* value, size_t size) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imchat::mutable_from() {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  return from_;
}
inline ::std::string* im_imchat::release_from() {
  clear_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_;
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imchat::set_allocated_from(::std::string* from) {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    delete from_;
  }
  if (from) {
    set_has_from();
    from_ = from;
  } else {
    clear_has_from();
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string type = 6;
inline bool im_imchat::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void im_imchat::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void im_imchat::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void im_imchat::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& im_imchat::type() const {
  return *type_;
}
inline void im_imchat::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void im_imchat::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void im_imchat::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imchat::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* im_imchat::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imchat::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string category = 7;
inline bool im_imchat::has_category() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void im_imchat::set_has_category() {
  _has_bits_[0] |= 0x00000040u;
}
inline void im_imchat::clear_has_category() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void im_imchat::clear_category() {
  if (category_ != &::google::protobuf::internal::kEmptyString) {
    category_->clear();
  }
  clear_has_category();
}
inline const ::std::string& im_imchat::category() const {
  return *category_;
}
inline void im_imchat::set_category(const ::std::string& value) {
  set_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    category_ = new ::std::string;
  }
  category_->assign(value);
}
inline void im_imchat::set_category(const char* value) {
  set_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    category_ = new ::std::string;
  }
  category_->assign(value);
}
inline void im_imchat::set_category(const char* value, size_t size) {
  set_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    category_ = new ::std::string;
  }
  category_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imchat::mutable_category() {
  set_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    category_ = new ::std::string;
  }
  return category_;
}
inline ::std::string* im_imchat::release_category() {
  clear_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = category_;
    category_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imchat::set_allocated_category(::std::string* category) {
  if (category_ != &::google::protobuf::internal::kEmptyString) {
    delete category_;
  }
  if (category) {
    set_has_category();
    category_ = category;
  } else {
    clear_has_category();
    category_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string time = 8;
inline bool im_imchat::has_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void im_imchat::set_has_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void im_imchat::clear_has_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void im_imchat::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& im_imchat::time() const {
  return *time_;
}
inline void im_imchat::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void im_imchat::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void im_imchat::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imchat::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* im_imchat::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imchat::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 issave = 9;
inline bool im_imchat::has_issave() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void im_imchat::set_has_issave() {
  _has_bits_[0] |= 0x00000100u;
}
inline void im_imchat::clear_has_issave() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void im_imchat::clear_issave() {
  issave_ = 0;
  clear_has_issave();
}
inline ::google::protobuf::int32 im_imchat::issave() const {
  return issave_;
}
inline void im_imchat::set_issave(::google::protobuf::int32 value) {
  set_has_issave();
  issave_ = value;
}

// optional int32 isshare = 10;
inline bool im_imchat::has_isshare() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void im_imchat::set_has_isshare() {
  _has_bits_[0] |= 0x00000200u;
}
inline void im_imchat::clear_has_isshare() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void im_imchat::clear_isshare() {
  isshare_ = 0;
  clear_has_isshare();
}
inline ::google::protobuf::int32 im_imchat::isshare() const {
  return isshare_;
}
inline void im_imchat::set_isshare(::google::protobuf::int32 value) {
  set_has_isshare();
  isshare_ = value;
}

// -------------------------------------------------------------------

// im_imclose

// required string user = 1;
inline bool im_imclose::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void im_imclose::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void im_imclose::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void im_imclose::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& im_imclose::user() const {
  return *user_;
}
inline void im_imclose::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void im_imclose::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void im_imclose::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imclose::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* im_imclose::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imclose::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string addr = 2;
inline bool im_imclose::has_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void im_imclose::set_has_addr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void im_imclose::clear_has_addr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void im_imclose::clear_addr() {
  if (addr_ != &::google::protobuf::internal::kEmptyString) {
    addr_->clear();
  }
  clear_has_addr();
}
inline const ::std::string& im_imclose::addr() const {
  return *addr_;
}
inline void im_imclose::set_addr(const ::std::string& value) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(value);
}
inline void im_imclose::set_addr(const char* value) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(value);
}
inline void im_imclose::set_addr(const char* value, size_t size) {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imclose::mutable_addr() {
  set_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    addr_ = new ::std::string;
  }
  return addr_;
}
inline ::std::string* im_imclose::release_addr() {
  clear_has_addr();
  if (addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = addr_;
    addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imclose::set_allocated_addr(::std::string* addr) {
  if (addr_ != &::google::protobuf::internal::kEmptyString) {
    delete addr_;
  }
  if (addr) {
    set_has_addr();
    addr_ = addr;
  } else {
    clear_has_addr();
    addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// im_imlogin

// optional string from = 1;
inline bool im_imlogin::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void im_imlogin::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void im_imlogin::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void im_imlogin::clear_from() {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    from_->clear();
  }
  clear_has_from();
}
inline const ::std::string& im_imlogin::from() const {
  return *from_;
}
inline void im_imlogin::set_from(const ::std::string& value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void im_imlogin::set_from(const char* value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void im_imlogin::set_from(const char* value, size_t size) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imlogin::mutable_from() {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  return from_;
}
inline ::std::string* im_imlogin::release_from() {
  clear_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_;
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imlogin::set_allocated_from(::std::string* from) {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    delete from_;
  }
  if (from) {
    set_has_from();
    from_ = from;
  } else {
    clear_has_from();
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string domain = 2;
inline bool im_imlogin::has_domain() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void im_imlogin::set_has_domain() {
  _has_bits_[0] |= 0x00000002u;
}
inline void im_imlogin::clear_has_domain() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void im_imlogin::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& im_imlogin::domain() const {
  return *domain_;
}
inline void im_imlogin::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void im_imlogin::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void im_imlogin::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imlogin::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* im_imlogin::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imlogin::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string platform = 3;
inline bool im_imlogin::has_platform() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void im_imlogin::set_has_platform() {
  _has_bits_[0] |= 0x00000004u;
}
inline void im_imlogin::clear_has_platform() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void im_imlogin::clear_platform() {
  if (platform_ != &::google::protobuf::internal::kEmptyString) {
    platform_->clear();
  }
  clear_has_platform();
}
inline const ::std::string& im_imlogin::platform() const {
  return *platform_;
}
inline void im_imlogin::set_platform(const ::std::string& value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void im_imlogin::set_platform(const char* value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void im_imlogin::set_platform(const char* value, size_t size) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imlogin::mutable_platform() {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  return platform_;
}
inline ::std::string* im_imlogin::release_platform() {
  clear_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = platform_;
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imlogin::set_allocated_platform(::std::string* platform) {
  if (platform_ != &::google::protobuf::internal::kEmptyString) {
    delete platform_;
  }
  if (platform) {
    set_has_platform();
    platform_ = platform;
  } else {
    clear_has_platform();
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string resource = 4;
inline bool im_imlogin::has_resource() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void im_imlogin::set_has_resource() {
  _has_bits_[0] |= 0x00000008u;
}
inline void im_imlogin::clear_has_resource() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void im_imlogin::clear_resource() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    resource_->clear();
  }
  clear_has_resource();
}
inline const ::std::string& im_imlogin::resource() const {
  return *resource_;
}
inline void im_imlogin::set_resource(const ::std::string& value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void im_imlogin::set_resource(const char* value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void im_imlogin::set_resource(const char* value, size_t size) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imlogin::mutable_resource() {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  return resource_;
}
inline ::std::string* im_imlogin::release_resource() {
  clear_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resource_;
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imlogin::set_allocated_resource(::std::string* resource) {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (resource) {
    set_has_resource();
    resource_ = resource;
  } else {
    clear_has_resource();
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 status = 5;
inline bool im_imlogin::has_status() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void im_imlogin::set_has_status() {
  _has_bits_[0] |= 0x00000010u;
}
inline void im_imlogin::clear_has_status() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void im_imlogin::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 im_imlogin::status() const {
  return status_;
}
inline void im_imlogin::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// im_imlogout

// optional int32 status = 1;
inline bool im_imlogout::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void im_imlogout::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void im_imlogout::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void im_imlogout::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 im_imlogout::status() const {
  return status_;
}
inline void im_imlogout::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// im_imupstream

// required string from = 1;
inline bool im_imupstream::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void im_imupstream::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void im_imupstream::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void im_imupstream::clear_from() {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    from_->clear();
  }
  clear_has_from();
}
inline const ::std::string& im_imupstream::from() const {
  return *from_;
}
inline void im_imupstream::set_from(const ::std::string& value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void im_imupstream::set_from(const char* value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void im_imupstream::set_from(const char* value, size_t size) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imupstream::mutable_from() {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  return from_;
}
inline ::std::string* im_imupstream::release_from() {
  clear_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_;
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imupstream::set_allocated_from(::std::string* from) {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    delete from_;
  }
  if (from) {
    set_has_from();
    from_ = from;
  } else {
    clear_has_from();
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string domain = 2;
inline bool im_imupstream::has_domain() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void im_imupstream::set_has_domain() {
  _has_bits_[0] |= 0x00000002u;
}
inline void im_imupstream::clear_has_domain() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void im_imupstream::clear_domain() {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    domain_->clear();
  }
  clear_has_domain();
}
inline const ::std::string& im_imupstream::domain() const {
  return *domain_;
}
inline void im_imupstream::set_domain(const ::std::string& value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void im_imupstream::set_domain(const char* value) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(value);
}
inline void im_imupstream::set_domain(const char* value, size_t size) {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  domain_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imupstream::mutable_domain() {
  set_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    domain_ = new ::std::string;
  }
  return domain_;
}
inline ::std::string* im_imupstream::release_domain() {
  clear_has_domain();
  if (domain_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = domain_;
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imupstream::set_allocated_domain(::std::string* domain) {
  if (domain_ != &::google::protobuf::internal::kEmptyString) {
    delete domain_;
  }
  if (domain) {
    set_has_domain();
    domain_ = domain;
  } else {
    clear_has_domain();
    domain_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string platform = 3;
inline bool im_imupstream::has_platform() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void im_imupstream::set_has_platform() {
  _has_bits_[0] |= 0x00000004u;
}
inline void im_imupstream::clear_has_platform() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void im_imupstream::clear_platform() {
  if (platform_ != &::google::protobuf::internal::kEmptyString) {
    platform_->clear();
  }
  clear_has_platform();
}
inline const ::std::string& im_imupstream::platform() const {
  return *platform_;
}
inline void im_imupstream::set_platform(const ::std::string& value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void im_imupstream::set_platform(const char* value) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(value);
}
inline void im_imupstream::set_platform(const char* value, size_t size) {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  platform_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imupstream::mutable_platform() {
  set_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    platform_ = new ::std::string;
  }
  return platform_;
}
inline ::std::string* im_imupstream::release_platform() {
  clear_has_platform();
  if (platform_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = platform_;
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imupstream::set_allocated_platform(::std::string* platform) {
  if (platform_ != &::google::protobuf::internal::kEmptyString) {
    delete platform_;
  }
  if (platform) {
    set_has_platform();
    platform_ = platform;
  } else {
    clear_has_platform();
    platform_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string resource = 4;
inline bool im_imupstream::has_resource() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void im_imupstream::set_has_resource() {
  _has_bits_[0] |= 0x00000008u;
}
inline void im_imupstream::clear_has_resource() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void im_imupstream::clear_resource() {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    resource_->clear();
  }
  clear_has_resource();
}
inline const ::std::string& im_imupstream::resource() const {
  return *resource_;
}
inline void im_imupstream::set_resource(const ::std::string& value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void im_imupstream::set_resource(const char* value) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(value);
}
inline void im_imupstream::set_resource(const char* value, size_t size) {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  resource_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imupstream::mutable_resource() {
  set_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    resource_ = new ::std::string;
  }
  return resource_;
}
inline ::std::string* im_imupstream::release_resource() {
  clear_has_resource();
  if (resource_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resource_;
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imupstream::set_allocated_resource(::std::string* resource) {
  if (resource_ != &::google::protobuf::internal::kEmptyString) {
    delete resource_;
  }
  if (resource) {
    set_has_resource();
    resource_ = resource;
  } else {
    clear_has_resource();
    resource_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// im_imkeepalive

// required string id = 1;
inline bool im_imkeepalive::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void im_imkeepalive::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void im_imkeepalive::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void im_imkeepalive::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& im_imkeepalive::id() const {
  return *id_;
}
inline void im_imkeepalive::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void im_imkeepalive::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void im_imkeepalive::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imkeepalive::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* im_imkeepalive::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imkeepalive::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// im_impgcreate

// required string id = 1;
inline bool im_impgcreate::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void im_impgcreate::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void im_impgcreate::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void im_impgcreate::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& im_impgcreate::id() const {
  return *id_;
}
inline void im_impgcreate::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void im_impgcreate::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void im_impgcreate::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_impgcreate::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* im_impgcreate::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_impgcreate::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string gid = 2;
inline bool im_impgcreate::has_gid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void im_impgcreate::set_has_gid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void im_impgcreate::clear_has_gid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void im_impgcreate::clear_gid() {
  if (gid_ != &::google::protobuf::internal::kEmptyString) {
    gid_->clear();
  }
  clear_has_gid();
}
inline const ::std::string& im_impgcreate::gid() const {
  return *gid_;
}
inline void im_impgcreate::set_gid(const ::std::string& value) {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    gid_ = new ::std::string;
  }
  gid_->assign(value);
}
inline void im_impgcreate::set_gid(const char* value) {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    gid_ = new ::std::string;
  }
  gid_->assign(value);
}
inline void im_impgcreate::set_gid(const char* value, size_t size) {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    gid_ = new ::std::string;
  }
  gid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_impgcreate::mutable_gid() {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    gid_ = new ::std::string;
  }
  return gid_;
}
inline ::std::string* im_impgcreate::release_gid() {
  clear_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gid_;
    gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_impgcreate::set_allocated_gid(::std::string* gid) {
  if (gid_ != &::google::protobuf::internal::kEmptyString) {
    delete gid_;
  }
  if (gid) {
    set_has_gid();
    gid_ = gid;
  } else {
    clear_has_gid();
    gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 3;
inline bool im_impgcreate::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void im_impgcreate::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void im_impgcreate::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void im_impgcreate::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& im_impgcreate::name() const {
  return *name_;
}
inline void im_impgcreate::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void im_impgcreate::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void im_impgcreate::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_impgcreate::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* im_impgcreate::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_impgcreate::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string time = 4;
inline bool im_impgcreate::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void im_impgcreate::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void im_impgcreate::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void im_impgcreate::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& im_impgcreate::time() const {
  return *time_;
}
inline void im_impgcreate::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void im_impgcreate::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void im_impgcreate::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_impgcreate::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* im_impgcreate::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_impgcreate::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 type = 5;
inline bool im_impgcreate::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void im_impgcreate::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void im_impgcreate::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void im_impgcreate::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 im_impgcreate::type() const {
  return type_;
}
inline void im_impgcreate::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// im_impginvite

// required string id = 1;
inline bool im_impginvite::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void im_impginvite::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void im_impginvite::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void im_impginvite::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& im_impginvite::id() const {
  return *id_;
}
inline void im_impginvite::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void im_impginvite::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void im_impginvite::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_impginvite::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* im_impginvite::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_impginvite::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string gid = 2;
inline bool im_impginvite::has_gid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void im_impginvite::set_has_gid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void im_impginvite::clear_has_gid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void im_impginvite::clear_gid() {
  if (gid_ != &::google::protobuf::internal::kEmptyString) {
    gid_->clear();
  }
  clear_has_gid();
}
inline const ::std::string& im_impginvite::gid() const {
  return *gid_;
}
inline void im_impginvite::set_gid(const ::std::string& value) {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    gid_ = new ::std::string;
  }
  gid_->assign(value);
}
inline void im_impginvite::set_gid(const char* value) {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    gid_ = new ::std::string;
  }
  gid_->assign(value);
}
inline void im_impginvite::set_gid(const char* value, size_t size) {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    gid_ = new ::std::string;
  }
  gid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_impginvite::mutable_gid() {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    gid_ = new ::std::string;
  }
  return gid_;
}
inline ::std::string* im_impginvite::release_gid() {
  clear_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gid_;
    gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_impginvite::set_allocated_gid(::std::string* gid) {
  if (gid_ != &::google::protobuf::internal::kEmptyString) {
    delete gid_;
  }
  if (gid) {
    set_has_gid();
    gid_ = gid;
  } else {
    clear_has_gid();
    gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 3;
inline bool im_impginvite::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void im_impginvite::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void im_impginvite::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void im_impginvite::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& im_impginvite::name() const {
  return *name_;
}
inline void im_impginvite::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void im_impginvite::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void im_impginvite::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_impginvite::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* im_impginvite::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_impginvite::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string time = 4;
inline bool im_impginvite::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void im_impginvite::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void im_impginvite::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void im_impginvite::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& im_impginvite::time() const {
  return *time_;
}
inline void im_impginvite::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void im_impginvite::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void im_impginvite::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_impginvite::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* im_impginvite::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_impginvite::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string invites = 5;
inline bool im_impginvite::has_invites() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void im_impginvite::set_has_invites() {
  _has_bits_[0] |= 0x00000010u;
}
inline void im_impginvite::clear_has_invites() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void im_impginvite::clear_invites() {
  if (invites_ != &::google::protobuf::internal::kEmptyString) {
    invites_->clear();
  }
  clear_has_invites();
}
inline const ::std::string& im_impginvite::invites() const {
  return *invites_;
}
inline void im_impginvite::set_invites(const ::std::string& value) {
  set_has_invites();
  if (invites_ == &::google::protobuf::internal::kEmptyString) {
    invites_ = new ::std::string;
  }
  invites_->assign(value);
}
inline void im_impginvite::set_invites(const char* value) {
  set_has_invites();
  if (invites_ == &::google::protobuf::internal::kEmptyString) {
    invites_ = new ::std::string;
  }
  invites_->assign(value);
}
inline void im_impginvite::set_invites(const char* value, size_t size) {
  set_has_invites();
  if (invites_ == &::google::protobuf::internal::kEmptyString) {
    invites_ = new ::std::string;
  }
  invites_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_impginvite::mutable_invites() {
  set_has_invites();
  if (invites_ == &::google::protobuf::internal::kEmptyString) {
    invites_ = new ::std::string;
  }
  return invites_;
}
inline ::std::string* im_impginvite::release_invites() {
  clear_has_invites();
  if (invites_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = invites_;
    invites_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_impginvite::set_allocated_invites(::std::string* invites) {
  if (invites_ != &::google::protobuf::internal::kEmptyString) {
    delete invites_;
  }
  if (invites) {
    set_has_invites();
    invites_ = invites;
  } else {
    clear_has_invites();
    invites_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 type = 6;
inline bool im_impginvite::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void im_impginvite::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void im_impginvite::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void im_impginvite::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 im_impginvite::type() const {
  return type_;
}
inline void im_impginvite::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// im_impgquit

// required string id = 1;
inline bool im_impgquit::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void im_impgquit::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void im_impgquit::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void im_impgquit::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& im_impgquit::id() const {
  return *id_;
}
inline void im_impgquit::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void im_impgquit::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void im_impgquit::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_impgquit::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* im_impgquit::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_impgquit::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string gid = 2;
inline bool im_impgquit::has_gid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void im_impgquit::set_has_gid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void im_impgquit::clear_has_gid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void im_impgquit::clear_gid() {
  if (gid_ != &::google::protobuf::internal::kEmptyString) {
    gid_->clear();
  }
  clear_has_gid();
}
inline const ::std::string& im_impgquit::gid() const {
  return *gid_;
}
inline void im_impgquit::set_gid(const ::std::string& value) {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    gid_ = new ::std::string;
  }
  gid_->assign(value);
}
inline void im_impgquit::set_gid(const char* value) {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    gid_ = new ::std::string;
  }
  gid_->assign(value);
}
inline void im_impgquit::set_gid(const char* value, size_t size) {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    gid_ = new ::std::string;
  }
  gid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_impgquit::mutable_gid() {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    gid_ = new ::std::string;
  }
  return gid_;
}
inline ::std::string* im_impgquit::release_gid() {
  clear_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gid_;
    gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_impgquit::set_allocated_gid(::std::string* gid) {
  if (gid_ != &::google::protobuf::internal::kEmptyString) {
    delete gid_;
  }
  if (gid) {
    set_has_gid();
    gid_ = gid;
  } else {
    clear_has_gid();
    gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string gkey = 3;
inline bool im_impgquit::has_gkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void im_impgquit::set_has_gkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void im_impgquit::clear_has_gkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void im_impgquit::clear_gkey() {
  if (gkey_ != &::google::protobuf::internal::kEmptyString) {
    gkey_->clear();
  }
  clear_has_gkey();
}
inline const ::std::string& im_impgquit::gkey() const {
  return *gkey_;
}
inline void im_impgquit::set_gkey(const ::std::string& value) {
  set_has_gkey();
  if (gkey_ == &::google::protobuf::internal::kEmptyString) {
    gkey_ = new ::std::string;
  }
  gkey_->assign(value);
}
inline void im_impgquit::set_gkey(const char* value) {
  set_has_gkey();
  if (gkey_ == &::google::protobuf::internal::kEmptyString) {
    gkey_ = new ::std::string;
  }
  gkey_->assign(value);
}
inline void im_impgquit::set_gkey(const char* value, size_t size) {
  set_has_gkey();
  if (gkey_ == &::google::protobuf::internal::kEmptyString) {
    gkey_ = new ::std::string;
  }
  gkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_impgquit::mutable_gkey() {
  set_has_gkey();
  if (gkey_ == &::google::protobuf::internal::kEmptyString) {
    gkey_ = new ::std::string;
  }
  return gkey_;
}
inline ::std::string* im_impgquit::release_gkey() {
  clear_has_gkey();
  if (gkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gkey_;
    gkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_impgquit::set_allocated_gkey(::std::string* gkey) {
  if (gkey_ != &::google::protobuf::internal::kEmptyString) {
    delete gkey_;
  }
  if (gkey) {
    set_has_gkey();
    gkey_ = gkey;
  } else {
    clear_has_gkey();
    gkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 4;
inline bool im_impgquit::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void im_impgquit::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void im_impgquit::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void im_impgquit::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& im_impgquit::name() const {
  return *name_;
}
inline void im_impgquit::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void im_impgquit::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void im_impgquit::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_impgquit::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* im_impgquit::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_impgquit::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string time = 5;
inline bool im_impgquit::has_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void im_impgquit::set_has_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void im_impgquit::clear_has_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void im_impgquit::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& im_impgquit::time() const {
  return *time_;
}
inline void im_impgquit::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void im_impgquit::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void im_impgquit::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_impgquit::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* im_impgquit::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_impgquit::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 type = 6;
inline bool im_impgquit::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void im_impgquit::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void im_impgquit::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void im_impgquit::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 im_impgquit::type() const {
  return type_;
}
inline void im_impgquit::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string uid = 7;
inline bool im_impgquit::has_uid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void im_impgquit::set_has_uid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void im_impgquit::clear_has_uid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void im_impgquit::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& im_impgquit::uid() const {
  return *uid_;
}
inline void im_impgquit::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void im_impgquit::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void im_impgquit::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_impgquit::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* im_impgquit::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_impgquit::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// im_impgmodify

// required string id = 1;
inline bool im_impgmodify::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void im_impgmodify::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void im_impgmodify::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void im_impgmodify::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& im_impgmodify::id() const {
  return *id_;
}
inline void im_impgmodify::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void im_impgmodify::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void im_impgmodify::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_impgmodify::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* im_impgmodify::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_impgmodify::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string gid = 2;
inline bool im_impgmodify::has_gid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void im_impgmodify::set_has_gid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void im_impgmodify::clear_has_gid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void im_impgmodify::clear_gid() {
  if (gid_ != &::google::protobuf::internal::kEmptyString) {
    gid_->clear();
  }
  clear_has_gid();
}
inline const ::std::string& im_impgmodify::gid() const {
  return *gid_;
}
inline void im_impgmodify::set_gid(const ::std::string& value) {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    gid_ = new ::std::string;
  }
  gid_->assign(value);
}
inline void im_impgmodify::set_gid(const char* value) {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    gid_ = new ::std::string;
  }
  gid_->assign(value);
}
inline void im_impgmodify::set_gid(const char* value, size_t size) {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    gid_ = new ::std::string;
  }
  gid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_impgmodify::mutable_gid() {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    gid_ = new ::std::string;
  }
  return gid_;
}
inline ::std::string* im_impgmodify::release_gid() {
  clear_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gid_;
    gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_impgmodify::set_allocated_gid(::std::string* gid) {
  if (gid_ != &::google::protobuf::internal::kEmptyString) {
    delete gid_;
  }
  if (gid) {
    set_has_gid();
    gid_ = gid;
  } else {
    clear_has_gid();
    gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string gname = 3;
inline bool im_impgmodify::has_gname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void im_impgmodify::set_has_gname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void im_impgmodify::clear_has_gname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void im_impgmodify::clear_gname() {
  if (gname_ != &::google::protobuf::internal::kEmptyString) {
    gname_->clear();
  }
  clear_has_gname();
}
inline const ::std::string& im_impgmodify::gname() const {
  return *gname_;
}
inline void im_impgmodify::set_gname(const ::std::string& value) {
  set_has_gname();
  if (gname_ == &::google::protobuf::internal::kEmptyString) {
    gname_ = new ::std::string;
  }
  gname_->assign(value);
}
inline void im_impgmodify::set_gname(const char* value) {
  set_has_gname();
  if (gname_ == &::google::protobuf::internal::kEmptyString) {
    gname_ = new ::std::string;
  }
  gname_->assign(value);
}
inline void im_impgmodify::set_gname(const char* value, size_t size) {
  set_has_gname();
  if (gname_ == &::google::protobuf::internal::kEmptyString) {
    gname_ = new ::std::string;
  }
  gname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_impgmodify::mutable_gname() {
  set_has_gname();
  if (gname_ == &::google::protobuf::internal::kEmptyString) {
    gname_ = new ::std::string;
  }
  return gname_;
}
inline ::std::string* im_impgmodify::release_gname() {
  clear_has_gname();
  if (gname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gname_;
    gname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_impgmodify::set_allocated_gname(::std::string* gname) {
  if (gname_ != &::google::protobuf::internal::kEmptyString) {
    delete gname_;
  }
  if (gname) {
    set_has_gname();
    gname_ = gname;
  } else {
    clear_has_gname();
    gname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 4;
inline bool im_impgmodify::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void im_impgmodify::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void im_impgmodify::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void im_impgmodify::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& im_impgmodify::name() const {
  return *name_;
}
inline void im_impgmodify::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void im_impgmodify::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void im_impgmodify::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_impgmodify::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* im_impgmodify::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_impgmodify::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string time = 5;
inline bool im_impgmodify::has_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void im_impgmodify::set_has_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void im_impgmodify::clear_has_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void im_impgmodify::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& im_impgmodify::time() const {
  return *time_;
}
inline void im_impgmodify::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void im_impgmodify::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void im_impgmodify::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_impgmodify::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* im_impgmodify::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_impgmodify::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 type = 6;
inline bool im_impgmodify::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void im_impgmodify::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void im_impgmodify::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void im_impgmodify::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 im_impgmodify::type() const {
  return type_;
}
inline void im_impgmodify::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// im_impgcard

// required string id = 1;
inline bool im_impgcard::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void im_impgcard::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void im_impgcard::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void im_impgcard::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& im_impgcard::id() const {
  return *id_;
}
inline void im_impgcard::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void im_impgcard::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void im_impgcard::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_impgcard::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* im_impgcard::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_impgcard::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string gid = 2;
inline bool im_impgcard::has_gid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void im_impgcard::set_has_gid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void im_impgcard::clear_has_gid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void im_impgcard::clear_gid() {
  if (gid_ != &::google::protobuf::internal::kEmptyString) {
    gid_->clear();
  }
  clear_has_gid();
}
inline const ::std::string& im_impgcard::gid() const {
  return *gid_;
}
inline void im_impgcard::set_gid(const ::std::string& value) {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    gid_ = new ::std::string;
  }
  gid_->assign(value);
}
inline void im_impgcard::set_gid(const char* value) {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    gid_ = new ::std::string;
  }
  gid_->assign(value);
}
inline void im_impgcard::set_gid(const char* value, size_t size) {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    gid_ = new ::std::string;
  }
  gid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_impgcard::mutable_gid() {
  set_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    gid_ = new ::std::string;
  }
  return gid_;
}
inline ::std::string* im_impgcard::release_gid() {
  clear_has_gid();
  if (gid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gid_;
    gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_impgcard::set_allocated_gid(::std::string* gid) {
  if (gid_ != &::google::protobuf::internal::kEmptyString) {
    delete gid_;
  }
  if (gid) {
    set_has_gid();
    gid_ = gid;
  } else {
    clear_has_gid();
    gid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string uid = 3;
inline bool im_impgcard::has_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void im_impgcard::set_has_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void im_impgcard::clear_has_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void im_impgcard::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& im_impgcard::uid() const {
  return *uid_;
}
inline void im_impgcard::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void im_impgcard::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void im_impgcard::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_impgcard::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* im_impgcard::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_impgcard::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string cardname = 4;
inline bool im_impgcard::has_cardname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void im_impgcard::set_has_cardname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void im_impgcard::clear_has_cardname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void im_impgcard::clear_cardname() {
  if (cardname_ != &::google::protobuf::internal::kEmptyString) {
    cardname_->clear();
  }
  clear_has_cardname();
}
inline const ::std::string& im_impgcard::cardname() const {
  return *cardname_;
}
inline void im_impgcard::set_cardname(const ::std::string& value) {
  set_has_cardname();
  if (cardname_ == &::google::protobuf::internal::kEmptyString) {
    cardname_ = new ::std::string;
  }
  cardname_->assign(value);
}
inline void im_impgcard::set_cardname(const char* value) {
  set_has_cardname();
  if (cardname_ == &::google::protobuf::internal::kEmptyString) {
    cardname_ = new ::std::string;
  }
  cardname_->assign(value);
}
inline void im_impgcard::set_cardname(const char* value, size_t size) {
  set_has_cardname();
  if (cardname_ == &::google::protobuf::internal::kEmptyString) {
    cardname_ = new ::std::string;
  }
  cardname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_impgcard::mutable_cardname() {
  set_has_cardname();
  if (cardname_ == &::google::protobuf::internal::kEmptyString) {
    cardname_ = new ::std::string;
  }
  return cardname_;
}
inline ::std::string* im_impgcard::release_cardname() {
  clear_has_cardname();
  if (cardname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cardname_;
    cardname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_impgcard::set_allocated_cardname(::std::string* cardname) {
  if (cardname_ != &::google::protobuf::internal::kEmptyString) {
    delete cardname_;
  }
  if (cardname) {
    set_has_cardname();
    cardname_ = cardname;
  } else {
    clear_has_cardname();
    cardname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string time = 5;
inline bool im_impgcard::has_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void im_impgcard::set_has_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void im_impgcard::clear_has_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void im_impgcard::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& im_impgcard::time() const {
  return *time_;
}
inline void im_impgcard::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void im_impgcard::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void im_impgcard::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_impgcard::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* im_impgcard::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_impgcard::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// im_imsns

// required string id = 1;
inline bool im_imsns::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void im_imsns::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void im_imsns::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void im_imsns::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& im_imsns::id() const {
  return *id_;
}
inline void im_imsns::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void im_imsns::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void im_imsns::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imsns::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* im_imsns::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imsns::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string subtype = 2;
inline bool im_imsns::has_subtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void im_imsns::set_has_subtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void im_imsns::clear_has_subtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void im_imsns::clear_subtype() {
  if (subtype_ != &::google::protobuf::internal::kEmptyString) {
    subtype_->clear();
  }
  clear_has_subtype();
}
inline const ::std::string& im_imsns::subtype() const {
  return *subtype_;
}
inline void im_imsns::set_subtype(const ::std::string& value) {
  set_has_subtype();
  if (subtype_ == &::google::protobuf::internal::kEmptyString) {
    subtype_ = new ::std::string;
  }
  subtype_->assign(value);
}
inline void im_imsns::set_subtype(const char* value) {
  set_has_subtype();
  if (subtype_ == &::google::protobuf::internal::kEmptyString) {
    subtype_ = new ::std::string;
  }
  subtype_->assign(value);
}
inline void im_imsns::set_subtype(const char* value, size_t size) {
  set_has_subtype();
  if (subtype_ == &::google::protobuf::internal::kEmptyString) {
    subtype_ = new ::std::string;
  }
  subtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imsns::mutable_subtype() {
  set_has_subtype();
  if (subtype_ == &::google::protobuf::internal::kEmptyString) {
    subtype_ = new ::std::string;
  }
  return subtype_;
}
inline ::std::string* im_imsns::release_subtype() {
  clear_has_subtype();
  if (subtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subtype_;
    subtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imsns::set_allocated_subtype(::std::string* subtype) {
  if (subtype_ != &::google::protobuf::internal::kEmptyString) {
    delete subtype_;
  }
  if (subtype) {
    set_has_subtype();
    subtype_ = subtype;
  } else {
    clear_has_subtype();
    subtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// im_imfansmodify

// required string id = 1;
inline bool im_imfansmodify::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void im_imfansmodify::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void im_imfansmodify::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void im_imfansmodify::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& im_imfansmodify::id() const {
  return *id_;
}
inline void im_imfansmodify::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void im_imfansmodify::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void im_imfansmodify::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imfansmodify::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* im_imfansmodify::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imfansmodify::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string uid = 2;
inline bool im_imfansmodify::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void im_imfansmodify::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void im_imfansmodify::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void im_imfansmodify::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& im_imfansmodify::uid() const {
  return *uid_;
}
inline void im_imfansmodify::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void im_imfansmodify::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void im_imfansmodify::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imfansmodify::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* im_imfansmodify::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imfansmodify::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 3;
inline bool im_imfansmodify::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void im_imfansmodify::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void im_imfansmodify::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void im_imfansmodify::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& im_imfansmodify::name() const {
  return *name_;
}
inline void im_imfansmodify::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void im_imfansmodify::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void im_imfansmodify::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imfansmodify::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* im_imfansmodify::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imfansmodify::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string key = 4;
inline bool im_imfansmodify::has_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void im_imfansmodify::set_has_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void im_imfansmodify::clear_has_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void im_imfansmodify::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& im_imfansmodify::key() const {
  return *key_;
}
inline void im_imfansmodify::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void im_imfansmodify::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void im_imfansmodify::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imfansmodify::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* im_imfansmodify::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imfansmodify::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string info = 5;
inline bool im_imfansmodify::has_info() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void im_imfansmodify::set_has_info() {
  _has_bits_[0] |= 0x00000010u;
}
inline void im_imfansmodify::clear_has_info() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void im_imfansmodify::clear_info() {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& im_imfansmodify::info() const {
  return *info_;
}
inline void im_imfansmodify::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void im_imfansmodify::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void im_imfansmodify::set_info(const char* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imfansmodify::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  return info_;
}
inline ::std::string* im_imfansmodify::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imfansmodify::set_allocated_info(::std::string* info) {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    delete info_;
  }
  if (info) {
    set_has_info();
    info_ = info;
  } else {
    clear_has_info();
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// im_imfansappend

// required string id = 1;
inline bool im_imfansappend::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void im_imfansappend::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void im_imfansappend::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void im_imfansappend::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& im_imfansappend::id() const {
  return *id_;
}
inline void im_imfansappend::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void im_imfansappend::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void im_imfansappend::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imfansappend::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* im_imfansappend::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imfansappend::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string uid = 2;
inline bool im_imfansappend::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void im_imfansappend::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void im_imfansappend::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void im_imfansappend::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& im_imfansappend::uid() const {
  return *uid_;
}
inline void im_imfansappend::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void im_imfansappend::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void im_imfansappend::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imfansappend::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* im_imfansappend::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imfansappend::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string key = 3;
inline bool im_imfansappend::has_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void im_imfansappend::set_has_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void im_imfansappend::clear_has_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void im_imfansappend::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& im_imfansappend::key() const {
  return *key_;
}
inline void im_imfansappend::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void im_imfansappend::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void im_imfansappend::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imfansappend::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* im_imfansappend::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imfansappend::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string time = 4;
inline bool im_imfansappend::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void im_imfansappend::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void im_imfansappend::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void im_imfansappend::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& im_imfansappend::time() const {
  return *time_;
}
inline void im_imfansappend::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void im_imfansappend::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void im_imfansappend::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imfansappend::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* im_imfansappend::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imfansappend::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string subtype = 5;
inline bool im_imfansappend::has_subtype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void im_imfansappend::set_has_subtype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void im_imfansappend::clear_has_subtype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void im_imfansappend::clear_subtype() {
  if (subtype_ != &::google::protobuf::internal::kEmptyString) {
    subtype_->clear();
  }
  clear_has_subtype();
}
inline const ::std::string& im_imfansappend::subtype() const {
  return *subtype_;
}
inline void im_imfansappend::set_subtype(const ::std::string& value) {
  set_has_subtype();
  if (subtype_ == &::google::protobuf::internal::kEmptyString) {
    subtype_ = new ::std::string;
  }
  subtype_->assign(value);
}
inline void im_imfansappend::set_subtype(const char* value) {
  set_has_subtype();
  if (subtype_ == &::google::protobuf::internal::kEmptyString) {
    subtype_ = new ::std::string;
  }
  subtype_->assign(value);
}
inline void im_imfansappend::set_subtype(const char* value, size_t size) {
  set_has_subtype();
  if (subtype_ == &::google::protobuf::internal::kEmptyString) {
    subtype_ = new ::std::string;
  }
  subtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imfansappend::mutable_subtype() {
  set_has_subtype();
  if (subtype_ == &::google::protobuf::internal::kEmptyString) {
    subtype_ = new ::std::string;
  }
  return subtype_;
}
inline ::std::string* im_imfansappend::release_subtype() {
  clear_has_subtype();
  if (subtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = subtype_;
    subtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imfansappend::set_allocated_subtype(::std::string* subtype) {
  if (subtype_ != &::google::protobuf::internal::kEmptyString) {
    delete subtype_;
  }
  if (subtype) {
    set_has_subtype();
    subtype_ = subtype;
  } else {
    clear_has_subtype();
    subtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 6;
inline bool im_imfansappend::has_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void im_imfansappend::set_has_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void im_imfansappend::clear_has_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void im_imfansappend::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& im_imfansappend::name() const {
  return *name_;
}
inline void im_imfansappend::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void im_imfansappend::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void im_imfansappend::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imfansappend::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* im_imfansappend::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imfansappend::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string info = 7;
inline bool im_imfansappend::has_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void im_imfansappend::set_has_info() {
  _has_bits_[0] |= 0x00000040u;
}
inline void im_imfansappend::clear_has_info() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void im_imfansappend::clear_info() {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    info_->clear();
  }
  clear_has_info();
}
inline const ::std::string& im_imfansappend::info() const {
  return *info_;
}
inline void im_imfansappend::set_info(const ::std::string& value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void im_imfansappend::set_info(const char* value) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(value);
}
inline void im_imfansappend::set_info(const char* value, size_t size) {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imfansappend::mutable_info() {
  set_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    info_ = new ::std::string;
  }
  return info_;
}
inline ::std::string* im_imfansappend::release_info() {
  clear_has_info();
  if (info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = info_;
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imfansappend::set_allocated_info(::std::string* info) {
  if (info_ != &::google::protobuf::internal::kEmptyString) {
    delete info_;
  }
  if (info) {
    set_has_info();
    info_ = info;
  } else {
    clear_has_info();
    info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string cmsid = 8;
inline bool im_imfansappend::has_cmsid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void im_imfansappend::set_has_cmsid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void im_imfansappend::clear_has_cmsid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void im_imfansappend::clear_cmsid() {
  if (cmsid_ != &::google::protobuf::internal::kEmptyString) {
    cmsid_->clear();
  }
  clear_has_cmsid();
}
inline const ::std::string& im_imfansappend::cmsid() const {
  return *cmsid_;
}
inline void im_imfansappend::set_cmsid(const ::std::string& value) {
  set_has_cmsid();
  if (cmsid_ == &::google::protobuf::internal::kEmptyString) {
    cmsid_ = new ::std::string;
  }
  cmsid_->assign(value);
}
inline void im_imfansappend::set_cmsid(const char* value) {
  set_has_cmsid();
  if (cmsid_ == &::google::protobuf::internal::kEmptyString) {
    cmsid_ = new ::std::string;
  }
  cmsid_->assign(value);
}
inline void im_imfansappend::set_cmsid(const char* value, size_t size) {
  set_has_cmsid();
  if (cmsid_ == &::google::protobuf::internal::kEmptyString) {
    cmsid_ = new ::std::string;
  }
  cmsid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imfansappend::mutable_cmsid() {
  set_has_cmsid();
  if (cmsid_ == &::google::protobuf::internal::kEmptyString) {
    cmsid_ = new ::std::string;
  }
  return cmsid_;
}
inline ::std::string* im_imfansappend::release_cmsid() {
  clear_has_cmsid();
  if (cmsid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cmsid_;
    cmsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imfansappend::set_allocated_cmsid(::std::string* cmsid) {
  if (cmsid_ != &::google::protobuf::internal::kEmptyString) {
    delete cmsid_;
  }
  if (cmsid) {
    set_has_cmsid();
    cmsid_ = cmsid;
  } else {
    clear_has_cmsid();
    cmsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// im_imfansdelete

// required string id = 1;
inline bool im_imfansdelete::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void im_imfansdelete::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void im_imfansdelete::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void im_imfansdelete::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& im_imfansdelete::id() const {
  return *id_;
}
inline void im_imfansdelete::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void im_imfansdelete::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void im_imfansdelete::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imfansdelete::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* im_imfansdelete::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imfansdelete::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string uid = 2;
inline bool im_imfansdelete::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void im_imfansdelete::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void im_imfansdelete::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void im_imfansdelete::clear_uid() {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    uid_->clear();
  }
  clear_has_uid();
}
inline const ::std::string& im_imfansdelete::uid() const {
  return *uid_;
}
inline void im_imfansdelete::set_uid(const ::std::string& value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void im_imfansdelete::set_uid(const char* value) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(value);
}
inline void im_imfansdelete::set_uid(const char* value, size_t size) {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  uid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imfansdelete::mutable_uid() {
  set_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    uid_ = new ::std::string;
  }
  return uid_;
}
inline ::std::string* im_imfansdelete::release_uid() {
  clear_has_uid();
  if (uid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uid_;
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imfansdelete::set_allocated_uid(::std::string* uid) {
  if (uid_ != &::google::protobuf::internal::kEmptyString) {
    delete uid_;
  }
  if (uid) {
    set_has_uid();
    uid_ = uid;
  } else {
    clear_has_uid();
    uid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string time = 3;
inline bool im_imfansdelete::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void im_imfansdelete::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void im_imfansdelete::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void im_imfansdelete::clear_time() {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    time_->clear();
  }
  clear_has_time();
}
inline const ::std::string& im_imfansdelete::time() const {
  return *time_;
}
inline void im_imfansdelete::set_time(const ::std::string& value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void im_imfansdelete::set_time(const char* value) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void im_imfansdelete::set_time(const char* value, size_t size) {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imfansdelete::mutable_time() {
  set_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    time_ = new ::std::string;
  }
  return time_;
}
inline ::std::string* im_imfansdelete::release_time() {
  clear_has_time();
  if (time_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = time_;
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imfansdelete::set_allocated_time(::std::string* time) {
  if (time_ != &::google::protobuf::internal::kEmptyString) {
    delete time_;
  }
  if (time) {
    set_has_time();
    time_ = time;
  } else {
    clear_has_time();
    time_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// im_immessage

// required string id = 1;
inline bool im_immessage::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void im_immessage::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void im_immessage::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void im_immessage::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& im_immessage::id() const {
  return *id_;
}
inline void im_immessage::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void im_immessage::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void im_immessage::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_immessage::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* im_immessage::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_immessage::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string touser = 2;
inline bool im_immessage::has_touser() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void im_immessage::set_has_touser() {
  _has_bits_[0] |= 0x00000002u;
}
inline void im_immessage::clear_has_touser() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void im_immessage::clear_touser() {
  if (touser_ != &::google::protobuf::internal::kEmptyString) {
    touser_->clear();
  }
  clear_has_touser();
}
inline const ::std::string& im_immessage::touser() const {
  return *touser_;
}
inline void im_immessage::set_touser(const ::std::string& value) {
  set_has_touser();
  if (touser_ == &::google::protobuf::internal::kEmptyString) {
    touser_ = new ::std::string;
  }
  touser_->assign(value);
}
inline void im_immessage::set_touser(const char* value) {
  set_has_touser();
  if (touser_ == &::google::protobuf::internal::kEmptyString) {
    touser_ = new ::std::string;
  }
  touser_->assign(value);
}
inline void im_immessage::set_touser(const char* value, size_t size) {
  set_has_touser();
  if (touser_ == &::google::protobuf::internal::kEmptyString) {
    touser_ = new ::std::string;
  }
  touser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_immessage::mutable_touser() {
  set_has_touser();
  if (touser_ == &::google::protobuf::internal::kEmptyString) {
    touser_ = new ::std::string;
  }
  return touser_;
}
inline ::std::string* im_immessage::release_touser() {
  clear_has_touser();
  if (touser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = touser_;
    touser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_immessage::set_allocated_touser(::std::string* touser) {
  if (touser_ != &::google::protobuf::internal::kEmptyString) {
    delete touser_;
  }
  if (touser) {
    set_has_touser();
    touser_ = touser;
  } else {
    clear_has_touser();
    touser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string msgtype = 3;
inline bool im_immessage::has_msgtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void im_immessage::set_has_msgtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void im_immessage::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void im_immessage::clear_msgtype() {
  if (msgtype_ != &::google::protobuf::internal::kEmptyString) {
    msgtype_->clear();
  }
  clear_has_msgtype();
}
inline const ::std::string& im_immessage::msgtype() const {
  return *msgtype_;
}
inline void im_immessage::set_msgtype(const ::std::string& value) {
  set_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::kEmptyString) {
    msgtype_ = new ::std::string;
  }
  msgtype_->assign(value);
}
inline void im_immessage::set_msgtype(const char* value) {
  set_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::kEmptyString) {
    msgtype_ = new ::std::string;
  }
  msgtype_->assign(value);
}
inline void im_immessage::set_msgtype(const char* value, size_t size) {
  set_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::kEmptyString) {
    msgtype_ = new ::std::string;
  }
  msgtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_immessage::mutable_msgtype() {
  set_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::kEmptyString) {
    msgtype_ = new ::std::string;
  }
  return msgtype_;
}
inline ::std::string* im_immessage::release_msgtype() {
  clear_has_msgtype();
  if (msgtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msgtype_;
    msgtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_immessage::set_allocated_msgtype(::std::string* msgtype) {
  if (msgtype_ != &::google::protobuf::internal::kEmptyString) {
    delete msgtype_;
  }
  if (msgtype) {
    set_has_msgtype();
    msgtype_ = msgtype;
  } else {
    clear_has_msgtype();
    msgtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string fromuser = 4;
inline bool im_immessage::has_fromuser() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void im_immessage::set_has_fromuser() {
  _has_bits_[0] |= 0x00000008u;
}
inline void im_immessage::clear_has_fromuser() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void im_immessage::clear_fromuser() {
  if (fromuser_ != &::google::protobuf::internal::kEmptyString) {
    fromuser_->clear();
  }
  clear_has_fromuser();
}
inline const ::std::string& im_immessage::fromuser() const {
  return *fromuser_;
}
inline void im_immessage::set_fromuser(const ::std::string& value) {
  set_has_fromuser();
  if (fromuser_ == &::google::protobuf::internal::kEmptyString) {
    fromuser_ = new ::std::string;
  }
  fromuser_->assign(value);
}
inline void im_immessage::set_fromuser(const char* value) {
  set_has_fromuser();
  if (fromuser_ == &::google::protobuf::internal::kEmptyString) {
    fromuser_ = new ::std::string;
  }
  fromuser_->assign(value);
}
inline void im_immessage::set_fromuser(const char* value, size_t size) {
  set_has_fromuser();
  if (fromuser_ == &::google::protobuf::internal::kEmptyString) {
    fromuser_ = new ::std::string;
  }
  fromuser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_immessage::mutable_fromuser() {
  set_has_fromuser();
  if (fromuser_ == &::google::protobuf::internal::kEmptyString) {
    fromuser_ = new ::std::string;
  }
  return fromuser_;
}
inline ::std::string* im_immessage::release_fromuser() {
  clear_has_fromuser();
  if (fromuser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fromuser_;
    fromuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_immessage::set_allocated_fromuser(::std::string* fromuser) {
  if (fromuser_ != &::google::protobuf::internal::kEmptyString) {
    delete fromuser_;
  }
  if (fromuser) {
    set_has_fromuser();
    fromuser_ = fromuser;
  } else {
    clear_has_fromuser();
    fromuser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string category = 5;
inline bool im_immessage::has_category() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void im_immessage::set_has_category() {
  _has_bits_[0] |= 0x00000010u;
}
inline void im_immessage::clear_has_category() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void im_immessage::clear_category() {
  if (category_ != &::google::protobuf::internal::kEmptyString) {
    category_->clear();
  }
  clear_has_category();
}
inline const ::std::string& im_immessage::category() const {
  return *category_;
}
inline void im_immessage::set_category(const ::std::string& value) {
  set_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    category_ = new ::std::string;
  }
  category_->assign(value);
}
inline void im_immessage::set_category(const char* value) {
  set_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    category_ = new ::std::string;
  }
  category_->assign(value);
}
inline void im_immessage::set_category(const char* value, size_t size) {
  set_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    category_ = new ::std::string;
  }
  category_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_immessage::mutable_category() {
  set_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    category_ = new ::std::string;
  }
  return category_;
}
inline ::std::string* im_immessage::release_category() {
  clear_has_category();
  if (category_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = category_;
    category_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_immessage::set_allocated_category(::std::string* category) {
  if (category_ != &::google::protobuf::internal::kEmptyString) {
    delete category_;
  }
  if (category) {
    set_has_category();
    category_ = category;
  } else {
    clear_has_category();
    category_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string imagekey = 6;
inline bool im_immessage::has_imagekey() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void im_immessage::set_has_imagekey() {
  _has_bits_[0] |= 0x00000020u;
}
inline void im_immessage::clear_has_imagekey() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void im_immessage::clear_imagekey() {
  if (imagekey_ != &::google::protobuf::internal::kEmptyString) {
    imagekey_->clear();
  }
  clear_has_imagekey();
}
inline const ::std::string& im_immessage::imagekey() const {
  return *imagekey_;
}
inline void im_immessage::set_imagekey(const ::std::string& value) {
  set_has_imagekey();
  if (imagekey_ == &::google::protobuf::internal::kEmptyString) {
    imagekey_ = new ::std::string;
  }
  imagekey_->assign(value);
}
inline void im_immessage::set_imagekey(const char* value) {
  set_has_imagekey();
  if (imagekey_ == &::google::protobuf::internal::kEmptyString) {
    imagekey_ = new ::std::string;
  }
  imagekey_->assign(value);
}
inline void im_immessage::set_imagekey(const char* value, size_t size) {
  set_has_imagekey();
  if (imagekey_ == &::google::protobuf::internal::kEmptyString) {
    imagekey_ = new ::std::string;
  }
  imagekey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_immessage::mutable_imagekey() {
  set_has_imagekey();
  if (imagekey_ == &::google::protobuf::internal::kEmptyString) {
    imagekey_ = new ::std::string;
  }
  return imagekey_;
}
inline ::std::string* im_immessage::release_imagekey() {
  clear_has_imagekey();
  if (imagekey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imagekey_;
    imagekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_immessage::set_allocated_imagekey(::std::string* imagekey) {
  if (imagekey_ != &::google::protobuf::internal::kEmptyString) {
    delete imagekey_;
  }
  if (imagekey) {
    set_has_imagekey();
    imagekey_ = imagekey;
  } else {
    clear_has_imagekey();
    imagekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string txtbuffer = 7;
inline bool im_immessage::has_txtbuffer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void im_immessage::set_has_txtbuffer() {
  _has_bits_[0] |= 0x00000040u;
}
inline void im_immessage::clear_has_txtbuffer() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void im_immessage::clear_txtbuffer() {
  if (txtbuffer_ != &::google::protobuf::internal::kEmptyString) {
    txtbuffer_->clear();
  }
  clear_has_txtbuffer();
}
inline const ::std::string& im_immessage::txtbuffer() const {
  return *txtbuffer_;
}
inline void im_immessage::set_txtbuffer(const ::std::string& value) {
  set_has_txtbuffer();
  if (txtbuffer_ == &::google::protobuf::internal::kEmptyString) {
    txtbuffer_ = new ::std::string;
  }
  txtbuffer_->assign(value);
}
inline void im_immessage::set_txtbuffer(const char* value) {
  set_has_txtbuffer();
  if (txtbuffer_ == &::google::protobuf::internal::kEmptyString) {
    txtbuffer_ = new ::std::string;
  }
  txtbuffer_->assign(value);
}
inline void im_immessage::set_txtbuffer(const char* value, size_t size) {
  set_has_txtbuffer();
  if (txtbuffer_ == &::google::protobuf::internal::kEmptyString) {
    txtbuffer_ = new ::std::string;
  }
  txtbuffer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_immessage::mutable_txtbuffer() {
  set_has_txtbuffer();
  if (txtbuffer_ == &::google::protobuf::internal::kEmptyString) {
    txtbuffer_ = new ::std::string;
  }
  return txtbuffer_;
}
inline ::std::string* im_immessage::release_txtbuffer() {
  clear_has_txtbuffer();
  if (txtbuffer_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txtbuffer_;
    txtbuffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_immessage::set_allocated_txtbuffer(::std::string* txtbuffer) {
  if (txtbuffer_ != &::google::protobuf::internal::kEmptyString) {
    delete txtbuffer_;
  }
  if (txtbuffer) {
    set_has_txtbuffer();
    txtbuffer_ = txtbuffer;
  } else {
    clear_has_txtbuffer();
    txtbuffer_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string imagewidth = 8;
inline bool im_immessage::has_imagewidth() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void im_immessage::set_has_imagewidth() {
  _has_bits_[0] |= 0x00000080u;
}
inline void im_immessage::clear_has_imagewidth() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void im_immessage::clear_imagewidth() {
  if (imagewidth_ != &::google::protobuf::internal::kEmptyString) {
    imagewidth_->clear();
  }
  clear_has_imagewidth();
}
inline const ::std::string& im_immessage::imagewidth() const {
  return *imagewidth_;
}
inline void im_immessage::set_imagewidth(const ::std::string& value) {
  set_has_imagewidth();
  if (imagewidth_ == &::google::protobuf::internal::kEmptyString) {
    imagewidth_ = new ::std::string;
  }
  imagewidth_->assign(value);
}
inline void im_immessage::set_imagewidth(const char* value) {
  set_has_imagewidth();
  if (imagewidth_ == &::google::protobuf::internal::kEmptyString) {
    imagewidth_ = new ::std::string;
  }
  imagewidth_->assign(value);
}
inline void im_immessage::set_imagewidth(const char* value, size_t size) {
  set_has_imagewidth();
  if (imagewidth_ == &::google::protobuf::internal::kEmptyString) {
    imagewidth_ = new ::std::string;
  }
  imagewidth_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_immessage::mutable_imagewidth() {
  set_has_imagewidth();
  if (imagewidth_ == &::google::protobuf::internal::kEmptyString) {
    imagewidth_ = new ::std::string;
  }
  return imagewidth_;
}
inline ::std::string* im_immessage::release_imagewidth() {
  clear_has_imagewidth();
  if (imagewidth_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imagewidth_;
    imagewidth_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_immessage::set_allocated_imagewidth(::std::string* imagewidth) {
  if (imagewidth_ != &::google::protobuf::internal::kEmptyString) {
    delete imagewidth_;
  }
  if (imagewidth) {
    set_has_imagewidth();
    imagewidth_ = imagewidth;
  } else {
    clear_has_imagewidth();
    imagewidth_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string imageheight = 9;
inline bool im_immessage::has_imageheight() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void im_immessage::set_has_imageheight() {
  _has_bits_[0] |= 0x00000100u;
}
inline void im_immessage::clear_has_imageheight() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void im_immessage::clear_imageheight() {
  if (imageheight_ != &::google::protobuf::internal::kEmptyString) {
    imageheight_->clear();
  }
  clear_has_imageheight();
}
inline const ::std::string& im_immessage::imageheight() const {
  return *imageheight_;
}
inline void im_immessage::set_imageheight(const ::std::string& value) {
  set_has_imageheight();
  if (imageheight_ == &::google::protobuf::internal::kEmptyString) {
    imageheight_ = new ::std::string;
  }
  imageheight_->assign(value);
}
inline void im_immessage::set_imageheight(const char* value) {
  set_has_imageheight();
  if (imageheight_ == &::google::protobuf::internal::kEmptyString) {
    imageheight_ = new ::std::string;
  }
  imageheight_->assign(value);
}
inline void im_immessage::set_imageheight(const char* value, size_t size) {
  set_has_imageheight();
  if (imageheight_ == &::google::protobuf::internal::kEmptyString) {
    imageheight_ = new ::std::string;
  }
  imageheight_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_immessage::mutable_imageheight() {
  set_has_imageheight();
  if (imageheight_ == &::google::protobuf::internal::kEmptyString) {
    imageheight_ = new ::std::string;
  }
  return imageheight_;
}
inline ::std::string* im_immessage::release_imageheight() {
  clear_has_imageheight();
  if (imageheight_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imageheight_;
    imageheight_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_immessage::set_allocated_imageheight(::std::string* imageheight) {
  if (imageheight_ != &::google::protobuf::internal::kEmptyString) {
    delete imageheight_;
  }
  if (imageheight) {
    set_has_imageheight();
    imageheight_ = imageheight;
  } else {
    clear_has_imageheight();
    imageheight_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string videolength = 10;
inline bool im_immessage::has_videolength() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void im_immessage::set_has_videolength() {
  _has_bits_[0] |= 0x00000200u;
}
inline void im_immessage::clear_has_videolength() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void im_immessage::clear_videolength() {
  if (videolength_ != &::google::protobuf::internal::kEmptyString) {
    videolength_->clear();
  }
  clear_has_videolength();
}
inline const ::std::string& im_immessage::videolength() const {
  return *videolength_;
}
inline void im_immessage::set_videolength(const ::std::string& value) {
  set_has_videolength();
  if (videolength_ == &::google::protobuf::internal::kEmptyString) {
    videolength_ = new ::std::string;
  }
  videolength_->assign(value);
}
inline void im_immessage::set_videolength(const char* value) {
  set_has_videolength();
  if (videolength_ == &::google::protobuf::internal::kEmptyString) {
    videolength_ = new ::std::string;
  }
  videolength_->assign(value);
}
inline void im_immessage::set_videolength(const char* value, size_t size) {
  set_has_videolength();
  if (videolength_ == &::google::protobuf::internal::kEmptyString) {
    videolength_ = new ::std::string;
  }
  videolength_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_immessage::mutable_videolength() {
  set_has_videolength();
  if (videolength_ == &::google::protobuf::internal::kEmptyString) {
    videolength_ = new ::std::string;
  }
  return videolength_;
}
inline ::std::string* im_immessage::release_videolength() {
  clear_has_videolength();
  if (videolength_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = videolength_;
    videolength_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_immessage::set_allocated_videolength(::std::string* videolength) {
  if (videolength_ != &::google::protobuf::internal::kEmptyString) {
    delete videolength_;
  }
  if (videolength) {
    set_has_videolength();
    videolength_ = videolength;
  } else {
    clear_has_videolength();
    videolength_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string videokey = 11;
inline bool im_immessage::has_videokey() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void im_immessage::set_has_videokey() {
  _has_bits_[0] |= 0x00000400u;
}
inline void im_immessage::clear_has_videokey() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void im_immessage::clear_videokey() {
  if (videokey_ != &::google::protobuf::internal::kEmptyString) {
    videokey_->clear();
  }
  clear_has_videokey();
}
inline const ::std::string& im_immessage::videokey() const {
  return *videokey_;
}
inline void im_immessage::set_videokey(const ::std::string& value) {
  set_has_videokey();
  if (videokey_ == &::google::protobuf::internal::kEmptyString) {
    videokey_ = new ::std::string;
  }
  videokey_->assign(value);
}
inline void im_immessage::set_videokey(const char* value) {
  set_has_videokey();
  if (videokey_ == &::google::protobuf::internal::kEmptyString) {
    videokey_ = new ::std::string;
  }
  videokey_->assign(value);
}
inline void im_immessage::set_videokey(const char* value, size_t size) {
  set_has_videokey();
  if (videokey_ == &::google::protobuf::internal::kEmptyString) {
    videokey_ = new ::std::string;
  }
  videokey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_immessage::mutable_videokey() {
  set_has_videokey();
  if (videokey_ == &::google::protobuf::internal::kEmptyString) {
    videokey_ = new ::std::string;
  }
  return videokey_;
}
inline ::std::string* im_immessage::release_videokey() {
  clear_has_videokey();
  if (videokey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = videokey_;
    videokey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_immessage::set_allocated_videokey(::std::string* videokey) {
  if (videokey_ != &::google::protobuf::internal::kEmptyString) {
    delete videokey_;
  }
  if (videokey) {
    set_has_videokey();
    videokey_ = videokey;
  } else {
    clear_has_videokey();
    videokey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string videotitle = 12;
inline bool im_immessage::has_videotitle() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void im_immessage::set_has_videotitle() {
  _has_bits_[0] |= 0x00000800u;
}
inline void im_immessage::clear_has_videotitle() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void im_immessage::clear_videotitle() {
  if (videotitle_ != &::google::protobuf::internal::kEmptyString) {
    videotitle_->clear();
  }
  clear_has_videotitle();
}
inline const ::std::string& im_immessage::videotitle() const {
  return *videotitle_;
}
inline void im_immessage::set_videotitle(const ::std::string& value) {
  set_has_videotitle();
  if (videotitle_ == &::google::protobuf::internal::kEmptyString) {
    videotitle_ = new ::std::string;
  }
  videotitle_->assign(value);
}
inline void im_immessage::set_videotitle(const char* value) {
  set_has_videotitle();
  if (videotitle_ == &::google::protobuf::internal::kEmptyString) {
    videotitle_ = new ::std::string;
  }
  videotitle_->assign(value);
}
inline void im_immessage::set_videotitle(const char* value, size_t size) {
  set_has_videotitle();
  if (videotitle_ == &::google::protobuf::internal::kEmptyString) {
    videotitle_ = new ::std::string;
  }
  videotitle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_immessage::mutable_videotitle() {
  set_has_videotitle();
  if (videotitle_ == &::google::protobuf::internal::kEmptyString) {
    videotitle_ = new ::std::string;
  }
  return videotitle_;
}
inline ::std::string* im_immessage::release_videotitle() {
  clear_has_videotitle();
  if (videotitle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = videotitle_;
    videotitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_immessage::set_allocated_videotitle(::std::string* videotitle) {
  if (videotitle_ != &::google::protobuf::internal::kEmptyString) {
    delete videotitle_;
  }
  if (videotitle) {
    set_has_videotitle();
    videotitle_ = videotitle;
  } else {
    clear_has_videotitle();
    videotitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// im_immappoint

// required string xpoint = 1;
inline bool im_immappoint::has_xpoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void im_immappoint::set_has_xpoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void im_immappoint::clear_has_xpoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void im_immappoint::clear_xpoint() {
  if (xpoint_ != &::google::protobuf::internal::kEmptyString) {
    xpoint_->clear();
  }
  clear_has_xpoint();
}
inline const ::std::string& im_immappoint::xpoint() const {
  return *xpoint_;
}
inline void im_immappoint::set_xpoint(const ::std::string& value) {
  set_has_xpoint();
  if (xpoint_ == &::google::protobuf::internal::kEmptyString) {
    xpoint_ = new ::std::string;
  }
  xpoint_->assign(value);
}
inline void im_immappoint::set_xpoint(const char* value) {
  set_has_xpoint();
  if (xpoint_ == &::google::protobuf::internal::kEmptyString) {
    xpoint_ = new ::std::string;
  }
  xpoint_->assign(value);
}
inline void im_immappoint::set_xpoint(const char* value, size_t size) {
  set_has_xpoint();
  if (xpoint_ == &::google::protobuf::internal::kEmptyString) {
    xpoint_ = new ::std::string;
  }
  xpoint_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_immappoint::mutable_xpoint() {
  set_has_xpoint();
  if (xpoint_ == &::google::protobuf::internal::kEmptyString) {
    xpoint_ = new ::std::string;
  }
  return xpoint_;
}
inline ::std::string* im_immappoint::release_xpoint() {
  clear_has_xpoint();
  if (xpoint_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = xpoint_;
    xpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_immappoint::set_allocated_xpoint(::std::string* xpoint) {
  if (xpoint_ != &::google::protobuf::internal::kEmptyString) {
    delete xpoint_;
  }
  if (xpoint) {
    set_has_xpoint();
    xpoint_ = xpoint;
  } else {
    clear_has_xpoint();
    xpoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string ypoint = 2;
inline bool im_immappoint::has_ypoint() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void im_immappoint::set_has_ypoint() {
  _has_bits_[0] |= 0x00000002u;
}
inline void im_immappoint::clear_has_ypoint() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void im_immappoint::clear_ypoint() {
  if (ypoint_ != &::google::protobuf::internal::kEmptyString) {
    ypoint_->clear();
  }
  clear_has_ypoint();
}
inline const ::std::string& im_immappoint::ypoint() const {
  return *ypoint_;
}
inline void im_immappoint::set_ypoint(const ::std::string& value) {
  set_has_ypoint();
  if (ypoint_ == &::google::protobuf::internal::kEmptyString) {
    ypoint_ = new ::std::string;
  }
  ypoint_->assign(value);
}
inline void im_immappoint::set_ypoint(const char* value) {
  set_has_ypoint();
  if (ypoint_ == &::google::protobuf::internal::kEmptyString) {
    ypoint_ = new ::std::string;
  }
  ypoint_->assign(value);
}
inline void im_immappoint::set_ypoint(const char* value, size_t size) {
  set_has_ypoint();
  if (ypoint_ == &::google::protobuf::internal::kEmptyString) {
    ypoint_ = new ::std::string;
  }
  ypoint_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_immappoint::mutable_ypoint() {
  set_has_ypoint();
  if (ypoint_ == &::google::protobuf::internal::kEmptyString) {
    ypoint_ = new ::std::string;
  }
  return ypoint_;
}
inline ::std::string* im_immappoint::release_ypoint() {
  clear_has_ypoint();
  if (ypoint_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ypoint_;
    ypoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_immappoint::set_allocated_ypoint(::std::string* ypoint) {
  if (ypoint_ != &::google::protobuf::internal::kEmptyString) {
    delete ypoint_;
  }
  if (ypoint) {
    set_has_ypoint();
    ypoint_ = ypoint;
  } else {
    clear_has_ypoint();
    ypoint_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// im_imdelete

// required string msgid = 1;
inline bool im_imdelete::has_msgid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void im_imdelete::set_has_msgid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void im_imdelete::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void im_imdelete::clear_msgid() {
  if (msgid_ != &::google::protobuf::internal::kEmptyString) {
    msgid_->clear();
  }
  clear_has_msgid();
}
inline const ::std::string& im_imdelete::msgid() const {
  return *msgid_;
}
inline void im_imdelete::set_msgid(const ::std::string& value) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(value);
}
inline void im_imdelete::set_msgid(const char* value) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(value);
}
inline void im_imdelete::set_msgid(const char* value, size_t size) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imdelete::mutable_msgid() {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    msgid_ = new ::std::string;
  }
  return msgid_;
}
inline ::std::string* im_imdelete::release_msgid() {
  clear_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msgid_;
    msgid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imdelete::set_allocated_msgid(::std::string* msgid) {
  if (msgid_ != &::google::protobuf::internal::kEmptyString) {
    delete msgid_;
  }
  if (msgid) {
    set_has_msgid();
    msgid_ = msgid;
  } else {
    clear_has_msgid();
    msgid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string imagekey = 2;
inline bool im_imdelete::has_imagekey() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void im_imdelete::set_has_imagekey() {
  _has_bits_[0] |= 0x00000002u;
}
inline void im_imdelete::clear_has_imagekey() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void im_imdelete::clear_imagekey() {
  if (imagekey_ != &::google::protobuf::internal::kEmptyString) {
    imagekey_->clear();
  }
  clear_has_imagekey();
}
inline const ::std::string& im_imdelete::imagekey() const {
  return *imagekey_;
}
inline void im_imdelete::set_imagekey(const ::std::string& value) {
  set_has_imagekey();
  if (imagekey_ == &::google::protobuf::internal::kEmptyString) {
    imagekey_ = new ::std::string;
  }
  imagekey_->assign(value);
}
inline void im_imdelete::set_imagekey(const char* value) {
  set_has_imagekey();
  if (imagekey_ == &::google::protobuf::internal::kEmptyString) {
    imagekey_ = new ::std::string;
  }
  imagekey_->assign(value);
}
inline void im_imdelete::set_imagekey(const char* value, size_t size) {
  set_has_imagekey();
  if (imagekey_ == &::google::protobuf::internal::kEmptyString) {
    imagekey_ = new ::std::string;
  }
  imagekey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imdelete::mutable_imagekey() {
  set_has_imagekey();
  if (imagekey_ == &::google::protobuf::internal::kEmptyString) {
    imagekey_ = new ::std::string;
  }
  return imagekey_;
}
inline ::std::string* im_imdelete::release_imagekey() {
  clear_has_imagekey();
  if (imagekey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imagekey_;
    imagekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imdelete::set_allocated_imagekey(::std::string* imagekey) {
  if (imagekey_ != &::google::protobuf::internal::kEmptyString) {
    delete imagekey_;
  }
  if (imagekey) {
    set_has_imagekey();
    imagekey_ = imagekey;
  } else {
    clear_has_imagekey();
    imagekey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string videokey = 3;
inline bool im_imdelete::has_videokey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void im_imdelete::set_has_videokey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void im_imdelete::clear_has_videokey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void im_imdelete::clear_videokey() {
  if (videokey_ != &::google::protobuf::internal::kEmptyString) {
    videokey_->clear();
  }
  clear_has_videokey();
}
inline const ::std::string& im_imdelete::videokey() const {
  return *videokey_;
}
inline void im_imdelete::set_videokey(const ::std::string& value) {
  set_has_videokey();
  if (videokey_ == &::google::protobuf::internal::kEmptyString) {
    videokey_ = new ::std::string;
  }
  videokey_->assign(value);
}
inline void im_imdelete::set_videokey(const char* value) {
  set_has_videokey();
  if (videokey_ == &::google::protobuf::internal::kEmptyString) {
    videokey_ = new ::std::string;
  }
  videokey_->assign(value);
}
inline void im_imdelete::set_videokey(const char* value, size_t size) {
  set_has_videokey();
  if (videokey_ == &::google::protobuf::internal::kEmptyString) {
    videokey_ = new ::std::string;
  }
  videokey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imdelete::mutable_videokey() {
  set_has_videokey();
  if (videokey_ == &::google::protobuf::internal::kEmptyString) {
    videokey_ = new ::std::string;
  }
  return videokey_;
}
inline ::std::string* im_imdelete::release_videokey() {
  clear_has_videokey();
  if (videokey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = videokey_;
    videokey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imdelete::set_allocated_videokey(::std::string* videokey) {
  if (videokey_ != &::google::protobuf::internal::kEmptyString) {
    delete videokey_;
  }
  if (videokey) {
    set_has_videokey();
    videokey_ = videokey;
  } else {
    clear_has_videokey();
    videokey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// im_imblacklist

// required int32 type = 1;
inline bool im_imblacklist::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void im_imblacklist::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void im_imblacklist::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void im_imblacklist::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 im_imblacklist::type() const {
  return type_;
}
inline void im_imblacklist::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string blackid = 2;
inline bool im_imblacklist::has_blackid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void im_imblacklist::set_has_blackid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void im_imblacklist::clear_has_blackid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void im_imblacklist::clear_blackid() {
  if (blackid_ != &::google::protobuf::internal::kEmptyString) {
    blackid_->clear();
  }
  clear_has_blackid();
}
inline const ::std::string& im_imblacklist::blackid() const {
  return *blackid_;
}
inline void im_imblacklist::set_blackid(const ::std::string& value) {
  set_has_blackid();
  if (blackid_ == &::google::protobuf::internal::kEmptyString) {
    blackid_ = new ::std::string;
  }
  blackid_->assign(value);
}
inline void im_imblacklist::set_blackid(const char* value) {
  set_has_blackid();
  if (blackid_ == &::google::protobuf::internal::kEmptyString) {
    blackid_ = new ::std::string;
  }
  blackid_->assign(value);
}
inline void im_imblacklist::set_blackid(const char* value, size_t size) {
  set_has_blackid();
  if (blackid_ == &::google::protobuf::internal::kEmptyString) {
    blackid_ = new ::std::string;
  }
  blackid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* im_imblacklist::mutable_blackid() {
  set_has_blackid();
  if (blackid_ == &::google::protobuf::internal::kEmptyString) {
    blackid_ = new ::std::string;
  }
  return blackid_;
}
inline ::std::string* im_imblacklist::release_blackid() {
  clear_has_blackid();
  if (blackid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = blackid_;
    blackid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void im_imblacklist::set_allocated_blackid(::std::string* blackid) {
  if (blackid_ != &::google::protobuf::internal::kEmptyString) {
    delete blackid_;
  }
  if (blackid) {
    set_has_blackid();
    blackid_ = blackid;
  } else {
    clear_has_blackid();
    blackid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// im

// required .im.im.Type msgtype = 1 [default = IM_ROOT];
inline bool im::has_msgtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void im::set_has_msgtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void im::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void im::clear_msgtype() {
  msgtype_ = 0;
  clear_has_msgtype();
}
inline ::im::im_Type im::msgtype() const {
  return static_cast< ::im::im_Type >(msgtype_);
}
inline void im::set_msgtype(::im::im_Type value) {
  assert(::im::im_Type_IsValid(value));
  set_has_msgtype();
  msgtype_ = value;
}

// optional .im.im.imack ack = 2;
inline bool im::has_ack() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void im::set_has_ack() {
  _has_bits_[0] |= 0x00000002u;
}
inline void im::clear_has_ack() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void im::clear_ack() {
  if (ack_ != NULL) ack_->::im::im_imack::Clear();
  clear_has_ack();
}
inline const ::im::im_imack& im::ack() const {
  return ack_ != NULL ? *ack_ : *default_instance_->ack_;
}
inline ::im::im_imack* im::mutable_ack() {
  set_has_ack();
  if (ack_ == NULL) ack_ = new ::im::im_imack;
  return ack_;
}
inline ::im::im_imack* im::release_ack() {
  clear_has_ack();
  ::im::im_imack* temp = ack_;
  ack_ = NULL;
  return temp;
}
inline void im::set_allocated_ack(::im::im_imack* ack) {
  delete ack_;
  ack_ = ack;
  if (ack) {
    set_has_ack();
  } else {
    clear_has_ack();
  }
}

// optional .im.im.imchat chat = 3;
inline bool im::has_chat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void im::set_has_chat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void im::clear_has_chat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void im::clear_chat() {
  if (chat_ != NULL) chat_->::im::im_imchat::Clear();
  clear_has_chat();
}
inline const ::im::im_imchat& im::chat() const {
  return chat_ != NULL ? *chat_ : *default_instance_->chat_;
}
inline ::im::im_imchat* im::mutable_chat() {
  set_has_chat();
  if (chat_ == NULL) chat_ = new ::im::im_imchat;
  return chat_;
}
inline ::im::im_imchat* im::release_chat() {
  clear_has_chat();
  ::im::im_imchat* temp = chat_;
  chat_ = NULL;
  return temp;
}
inline void im::set_allocated_chat(::im::im_imchat* chat) {
  delete chat_;
  chat_ = chat;
  if (chat) {
    set_has_chat();
  } else {
    clear_has_chat();
  }
}

// optional .im.im.imclose close = 4;
inline bool im::has_close() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void im::set_has_close() {
  _has_bits_[0] |= 0x00000008u;
}
inline void im::clear_has_close() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void im::clear_close() {
  if (close_ != NULL) close_->::im::im_imclose::Clear();
  clear_has_close();
}
inline const ::im::im_imclose& im::close() const {
  return close_ != NULL ? *close_ : *default_instance_->close_;
}
inline ::im::im_imclose* im::mutable_close() {
  set_has_close();
  if (close_ == NULL) close_ = new ::im::im_imclose;
  return close_;
}
inline ::im::im_imclose* im::release_close() {
  clear_has_close();
  ::im::im_imclose* temp = close_;
  close_ = NULL;
  return temp;
}
inline void im::set_allocated_close(::im::im_imclose* close) {
  delete close_;
  close_ = close;
  if (close) {
    set_has_close();
  } else {
    clear_has_close();
  }
}

// optional .im.im.imlogin login = 5;
inline bool im::has_login() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void im::set_has_login() {
  _has_bits_[0] |= 0x00000010u;
}
inline void im::clear_has_login() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void im::clear_login() {
  if (login_ != NULL) login_->::im::im_imlogin::Clear();
  clear_has_login();
}
inline const ::im::im_imlogin& im::login() const {
  return login_ != NULL ? *login_ : *default_instance_->login_;
}
inline ::im::im_imlogin* im::mutable_login() {
  set_has_login();
  if (login_ == NULL) login_ = new ::im::im_imlogin;
  return login_;
}
inline ::im::im_imlogin* im::release_login() {
  clear_has_login();
  ::im::im_imlogin* temp = login_;
  login_ = NULL;
  return temp;
}
inline void im::set_allocated_login(::im::im_imlogin* login) {
  delete login_;
  login_ = login;
  if (login) {
    set_has_login();
  } else {
    clear_has_login();
  }
}

// optional .im.im.imlogout logout = 6;
inline bool im::has_logout() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void im::set_has_logout() {
  _has_bits_[0] |= 0x00000020u;
}
inline void im::clear_has_logout() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void im::clear_logout() {
  if (logout_ != NULL) logout_->::im::im_imlogout::Clear();
  clear_has_logout();
}
inline const ::im::im_imlogout& im::logout() const {
  return logout_ != NULL ? *logout_ : *default_instance_->logout_;
}
inline ::im::im_imlogout* im::mutable_logout() {
  set_has_logout();
  if (logout_ == NULL) logout_ = new ::im::im_imlogout;
  return logout_;
}
inline ::im::im_imlogout* im::release_logout() {
  clear_has_logout();
  ::im::im_imlogout* temp = logout_;
  logout_ = NULL;
  return temp;
}
inline void im::set_allocated_logout(::im::im_imlogout* logout) {
  delete logout_;
  logout_ = logout;
  if (logout) {
    set_has_logout();
  } else {
    clear_has_logout();
  }
}

// optional .im.im.imupstream upstream = 7;
inline bool im::has_upstream() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void im::set_has_upstream() {
  _has_bits_[0] |= 0x00000040u;
}
inline void im::clear_has_upstream() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void im::clear_upstream() {
  if (upstream_ != NULL) upstream_->::im::im_imupstream::Clear();
  clear_has_upstream();
}
inline const ::im::im_imupstream& im::upstream() const {
  return upstream_ != NULL ? *upstream_ : *default_instance_->upstream_;
}
inline ::im::im_imupstream* im::mutable_upstream() {
  set_has_upstream();
  if (upstream_ == NULL) upstream_ = new ::im::im_imupstream;
  return upstream_;
}
inline ::im::im_imupstream* im::release_upstream() {
  clear_has_upstream();
  ::im::im_imupstream* temp = upstream_;
  upstream_ = NULL;
  return temp;
}
inline void im::set_allocated_upstream(::im::im_imupstream* upstream) {
  delete upstream_;
  upstream_ = upstream;
  if (upstream) {
    set_has_upstream();
  } else {
    clear_has_upstream();
  }
}

// optional .im.im.imkeepalive keepalive = 8;
inline bool im::has_keepalive() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void im::set_has_keepalive() {
  _has_bits_[0] |= 0x00000080u;
}
inline void im::clear_has_keepalive() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void im::clear_keepalive() {
  if (keepalive_ != NULL) keepalive_->::im::im_imkeepalive::Clear();
  clear_has_keepalive();
}
inline const ::im::im_imkeepalive& im::keepalive() const {
  return keepalive_ != NULL ? *keepalive_ : *default_instance_->keepalive_;
}
inline ::im::im_imkeepalive* im::mutable_keepalive() {
  set_has_keepalive();
  if (keepalive_ == NULL) keepalive_ = new ::im::im_imkeepalive;
  return keepalive_;
}
inline ::im::im_imkeepalive* im::release_keepalive() {
  clear_has_keepalive();
  ::im::im_imkeepalive* temp = keepalive_;
  keepalive_ = NULL;
  return temp;
}
inline void im::set_allocated_keepalive(::im::im_imkeepalive* keepalive) {
  delete keepalive_;
  keepalive_ = keepalive;
  if (keepalive) {
    set_has_keepalive();
  } else {
    clear_has_keepalive();
  }
}

// optional .im.im.impgcreate pgcreate = 9;
inline bool im::has_pgcreate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void im::set_has_pgcreate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void im::clear_has_pgcreate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void im::clear_pgcreate() {
  if (pgcreate_ != NULL) pgcreate_->::im::im_impgcreate::Clear();
  clear_has_pgcreate();
}
inline const ::im::im_impgcreate& im::pgcreate() const {
  return pgcreate_ != NULL ? *pgcreate_ : *default_instance_->pgcreate_;
}
inline ::im::im_impgcreate* im::mutable_pgcreate() {
  set_has_pgcreate();
  if (pgcreate_ == NULL) pgcreate_ = new ::im::im_impgcreate;
  return pgcreate_;
}
inline ::im::im_impgcreate* im::release_pgcreate() {
  clear_has_pgcreate();
  ::im::im_impgcreate* temp = pgcreate_;
  pgcreate_ = NULL;
  return temp;
}
inline void im::set_allocated_pgcreate(::im::im_impgcreate* pgcreate) {
  delete pgcreate_;
  pgcreate_ = pgcreate;
  if (pgcreate) {
    set_has_pgcreate();
  } else {
    clear_has_pgcreate();
  }
}

// optional .im.im.impginvite pginvite = 10;
inline bool im::has_pginvite() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void im::set_has_pginvite() {
  _has_bits_[0] |= 0x00000200u;
}
inline void im::clear_has_pginvite() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void im::clear_pginvite() {
  if (pginvite_ != NULL) pginvite_->::im::im_impginvite::Clear();
  clear_has_pginvite();
}
inline const ::im::im_impginvite& im::pginvite() const {
  return pginvite_ != NULL ? *pginvite_ : *default_instance_->pginvite_;
}
inline ::im::im_impginvite* im::mutable_pginvite() {
  set_has_pginvite();
  if (pginvite_ == NULL) pginvite_ = new ::im::im_impginvite;
  return pginvite_;
}
inline ::im::im_impginvite* im::release_pginvite() {
  clear_has_pginvite();
  ::im::im_impginvite* temp = pginvite_;
  pginvite_ = NULL;
  return temp;
}
inline void im::set_allocated_pginvite(::im::im_impginvite* pginvite) {
  delete pginvite_;
  pginvite_ = pginvite;
  if (pginvite) {
    set_has_pginvite();
  } else {
    clear_has_pginvite();
  }
}

// optional .im.im.impgquit pgquit = 11;
inline bool im::has_pgquit() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void im::set_has_pgquit() {
  _has_bits_[0] |= 0x00000400u;
}
inline void im::clear_has_pgquit() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void im::clear_pgquit() {
  if (pgquit_ != NULL) pgquit_->::im::im_impgquit::Clear();
  clear_has_pgquit();
}
inline const ::im::im_impgquit& im::pgquit() const {
  return pgquit_ != NULL ? *pgquit_ : *default_instance_->pgquit_;
}
inline ::im::im_impgquit* im::mutable_pgquit() {
  set_has_pgquit();
  if (pgquit_ == NULL) pgquit_ = new ::im::im_impgquit;
  return pgquit_;
}
inline ::im::im_impgquit* im::release_pgquit() {
  clear_has_pgquit();
  ::im::im_impgquit* temp = pgquit_;
  pgquit_ = NULL;
  return temp;
}
inline void im::set_allocated_pgquit(::im::im_impgquit* pgquit) {
  delete pgquit_;
  pgquit_ = pgquit;
  if (pgquit) {
    set_has_pgquit();
  } else {
    clear_has_pgquit();
  }
}

// optional .im.im.impgmodify pgmodify = 12;
inline bool im::has_pgmodify() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void im::set_has_pgmodify() {
  _has_bits_[0] |= 0x00000800u;
}
inline void im::clear_has_pgmodify() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void im::clear_pgmodify() {
  if (pgmodify_ != NULL) pgmodify_->::im::im_impgmodify::Clear();
  clear_has_pgmodify();
}
inline const ::im::im_impgmodify& im::pgmodify() const {
  return pgmodify_ != NULL ? *pgmodify_ : *default_instance_->pgmodify_;
}
inline ::im::im_impgmodify* im::mutable_pgmodify() {
  set_has_pgmodify();
  if (pgmodify_ == NULL) pgmodify_ = new ::im::im_impgmodify;
  return pgmodify_;
}
inline ::im::im_impgmodify* im::release_pgmodify() {
  clear_has_pgmodify();
  ::im::im_impgmodify* temp = pgmodify_;
  pgmodify_ = NULL;
  return temp;
}
inline void im::set_allocated_pgmodify(::im::im_impgmodify* pgmodify) {
  delete pgmodify_;
  pgmodify_ = pgmodify;
  if (pgmodify) {
    set_has_pgmodify();
  } else {
    clear_has_pgmodify();
  }
}

// optional .im.im.impgcard pgcard = 13;
inline bool im::has_pgcard() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void im::set_has_pgcard() {
  _has_bits_[0] |= 0x00001000u;
}
inline void im::clear_has_pgcard() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void im::clear_pgcard() {
  if (pgcard_ != NULL) pgcard_->::im::im_impgcard::Clear();
  clear_has_pgcard();
}
inline const ::im::im_impgcard& im::pgcard() const {
  return pgcard_ != NULL ? *pgcard_ : *default_instance_->pgcard_;
}
inline ::im::im_impgcard* im::mutable_pgcard() {
  set_has_pgcard();
  if (pgcard_ == NULL) pgcard_ = new ::im::im_impgcard;
  return pgcard_;
}
inline ::im::im_impgcard* im::release_pgcard() {
  clear_has_pgcard();
  ::im::im_impgcard* temp = pgcard_;
  pgcard_ = NULL;
  return temp;
}
inline void im::set_allocated_pgcard(::im::im_impgcard* pgcard) {
  delete pgcard_;
  pgcard_ = pgcard;
  if (pgcard) {
    set_has_pgcard();
  } else {
    clear_has_pgcard();
  }
}

// optional .im.im.imsns sns = 14;
inline bool im::has_sns() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void im::set_has_sns() {
  _has_bits_[0] |= 0x00002000u;
}
inline void im::clear_has_sns() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void im::clear_sns() {
  if (sns_ != NULL) sns_->::im::im_imsns::Clear();
  clear_has_sns();
}
inline const ::im::im_imsns& im::sns() const {
  return sns_ != NULL ? *sns_ : *default_instance_->sns_;
}
inline ::im::im_imsns* im::mutable_sns() {
  set_has_sns();
  if (sns_ == NULL) sns_ = new ::im::im_imsns;
  return sns_;
}
inline ::im::im_imsns* im::release_sns() {
  clear_has_sns();
  ::im::im_imsns* temp = sns_;
  sns_ = NULL;
  return temp;
}
inline void im::set_allocated_sns(::im::im_imsns* sns) {
  delete sns_;
  sns_ = sns;
  if (sns) {
    set_has_sns();
  } else {
    clear_has_sns();
  }
}

// optional .im.im.imfansmodify fansmodify = 15;
inline bool im::has_fansmodify() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void im::set_has_fansmodify() {
  _has_bits_[0] |= 0x00004000u;
}
inline void im::clear_has_fansmodify() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void im::clear_fansmodify() {
  if (fansmodify_ != NULL) fansmodify_->::im::im_imfansmodify::Clear();
  clear_has_fansmodify();
}
inline const ::im::im_imfansmodify& im::fansmodify() const {
  return fansmodify_ != NULL ? *fansmodify_ : *default_instance_->fansmodify_;
}
inline ::im::im_imfansmodify* im::mutable_fansmodify() {
  set_has_fansmodify();
  if (fansmodify_ == NULL) fansmodify_ = new ::im::im_imfansmodify;
  return fansmodify_;
}
inline ::im::im_imfansmodify* im::release_fansmodify() {
  clear_has_fansmodify();
  ::im::im_imfansmodify* temp = fansmodify_;
  fansmodify_ = NULL;
  return temp;
}
inline void im::set_allocated_fansmodify(::im::im_imfansmodify* fansmodify) {
  delete fansmodify_;
  fansmodify_ = fansmodify;
  if (fansmodify) {
    set_has_fansmodify();
  } else {
    clear_has_fansmodify();
  }
}

// optional .im.im.imfansappend fansappend = 16;
inline bool im::has_fansappend() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void im::set_has_fansappend() {
  _has_bits_[0] |= 0x00008000u;
}
inline void im::clear_has_fansappend() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void im::clear_fansappend() {
  if (fansappend_ != NULL) fansappend_->::im::im_imfansappend::Clear();
  clear_has_fansappend();
}
inline const ::im::im_imfansappend& im::fansappend() const {
  return fansappend_ != NULL ? *fansappend_ : *default_instance_->fansappend_;
}
inline ::im::im_imfansappend* im::mutable_fansappend() {
  set_has_fansappend();
  if (fansappend_ == NULL) fansappend_ = new ::im::im_imfansappend;
  return fansappend_;
}
inline ::im::im_imfansappend* im::release_fansappend() {
  clear_has_fansappend();
  ::im::im_imfansappend* temp = fansappend_;
  fansappend_ = NULL;
  return temp;
}
inline void im::set_allocated_fansappend(::im::im_imfansappend* fansappend) {
  delete fansappend_;
  fansappend_ = fansappend;
  if (fansappend) {
    set_has_fansappend();
  } else {
    clear_has_fansappend();
  }
}

// optional .im.im.imfansdelete fansdelete = 17;
inline bool im::has_fansdelete() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void im::set_has_fansdelete() {
  _has_bits_[0] |= 0x00010000u;
}
inline void im::clear_has_fansdelete() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void im::clear_fansdelete() {
  if (fansdelete_ != NULL) fansdelete_->::im::im_imfansdelete::Clear();
  clear_has_fansdelete();
}
inline const ::im::im_imfansdelete& im::fansdelete() const {
  return fansdelete_ != NULL ? *fansdelete_ : *default_instance_->fansdelete_;
}
inline ::im::im_imfansdelete* im::mutable_fansdelete() {
  set_has_fansdelete();
  if (fansdelete_ == NULL) fansdelete_ = new ::im::im_imfansdelete;
  return fansdelete_;
}
inline ::im::im_imfansdelete* im::release_fansdelete() {
  clear_has_fansdelete();
  ::im::im_imfansdelete* temp = fansdelete_;
  fansdelete_ = NULL;
  return temp;
}
inline void im::set_allocated_fansdelete(::im::im_imfansdelete* fansdelete) {
  delete fansdelete_;
  fansdelete_ = fansdelete;
  if (fansdelete) {
    set_has_fansdelete();
  } else {
    clear_has_fansdelete();
  }
}

// optional .im.im.immessage message = 18;
inline bool im::has_message() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void im::set_has_message() {
  _has_bits_[0] |= 0x00020000u;
}
inline void im::clear_has_message() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void im::clear_message() {
  if (message_ != NULL) message_->::im::im_immessage::Clear();
  clear_has_message();
}
inline const ::im::im_immessage& im::message() const {
  return message_ != NULL ? *message_ : *default_instance_->message_;
}
inline ::im::im_immessage* im::mutable_message() {
  set_has_message();
  if (message_ == NULL) message_ = new ::im::im_immessage;
  return message_;
}
inline ::im::im_immessage* im::release_message() {
  clear_has_message();
  ::im::im_immessage* temp = message_;
  message_ = NULL;
  return temp;
}
inline void im::set_allocated_message(::im::im_immessage* message) {
  delete message_;
  message_ = message;
  if (message) {
    set_has_message();
  } else {
    clear_has_message();
  }
}

// optional .im.im.immappoint mappoint = 19;
inline bool im::has_mappoint() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void im::set_has_mappoint() {
  _has_bits_[0] |= 0x00040000u;
}
inline void im::clear_has_mappoint() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void im::clear_mappoint() {
  if (mappoint_ != NULL) mappoint_->::im::im_immappoint::Clear();
  clear_has_mappoint();
}
inline const ::im::im_immappoint& im::mappoint() const {
  return mappoint_ != NULL ? *mappoint_ : *default_instance_->mappoint_;
}
inline ::im::im_immappoint* im::mutable_mappoint() {
  set_has_mappoint();
  if (mappoint_ == NULL) mappoint_ = new ::im::im_immappoint;
  return mappoint_;
}
inline ::im::im_immappoint* im::release_mappoint() {
  clear_has_mappoint();
  ::im::im_immappoint* temp = mappoint_;
  mappoint_ = NULL;
  return temp;
}
inline void im::set_allocated_mappoint(::im::im_immappoint* mappoint) {
  delete mappoint_;
  mappoint_ = mappoint;
  if (mappoint) {
    set_has_mappoint();
  } else {
    clear_has_mappoint();
  }
}

// optional .im.im.imdelete delete_ = 20;
inline bool im::has_delete_() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void im::set_has_delete_() {
  _has_bits_[0] |= 0x00080000u;
}
inline void im::clear_has_delete_() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void im::clear_delete_() {
  if (delete__ != NULL) delete__->::im::im_imdelete::Clear();
  clear_has_delete_();
}
inline const ::im::im_imdelete& im::delete_() const {
  return delete__ != NULL ? *delete__ : *default_instance_->delete__;
}
inline ::im::im_imdelete* im::mutable_delete_() {
  set_has_delete_();
  if (delete__ == NULL) delete__ = new ::im::im_imdelete;
  return delete__;
}
inline ::im::im_imdelete* im::release_delete_() {
  clear_has_delete_();
  ::im::im_imdelete* temp = delete__;
  delete__ = NULL;
  return temp;
}
inline void im::set_allocated_delete_(::im::im_imdelete* delete_) {
  delete delete__;
  delete__ = delete_;
  if (delete_) {
    set_has_delete_();
  } else {
    clear_has_delete_();
  }
}

// optional .im.im.imblacklist blacklist_ = 21;
inline bool im::has_blacklist_() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void im::set_has_blacklist_() {
  _has_bits_[0] |= 0x00100000u;
}
inline void im::clear_has_blacklist_() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void im::clear_blacklist_() {
  if (blacklist__ != NULL) blacklist__->::im::im_imblacklist::Clear();
  clear_has_blacklist_();
}
inline const ::im::im_imblacklist& im::blacklist_() const {
  return blacklist__ != NULL ? *blacklist__ : *default_instance_->blacklist__;
}
inline ::im::im_imblacklist* im::mutable_blacklist_() {
  set_has_blacklist_();
  if (blacklist__ == NULL) blacklist__ = new ::im::im_imblacklist;
  return blacklist__;
}
inline ::im::im_imblacklist* im::release_blacklist_() {
  clear_has_blacklist_();
  ::im::im_imblacklist* temp = blacklist__;
  blacklist__ = NULL;
  return temp;
}
inline void im::set_allocated_blacklist_(::im::im_imblacklist* blacklist_) {
  delete blacklist__;
  blacklist__ = blacklist_;
  if (blacklist_) {
    set_has_blacklist_();
  } else {
    clear_has_blacklist_();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace im

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::im::im_Type>() {
  return ::im::im_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_im_2eproto__INCLUDED
